<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[手写VUE2.0实现数据响应]]></title>
    <url>%2F2020%2F03%2F31%2Fvue2Resource%2F</url>
    <content type="text"><![CDATA[响应式原理响应式原理核心基础的一块就是 Observer/Watcher/Dep, 简而言之就是，Vue 是如何拦截数据的读写， 如果实现对应的监听，并且特定的监听执行特定的回调或者渲染逻辑的。总的可以拆成三大块来说。这一块，主要说的是 Vue 是如何将一个 plain object 给处理成 reactive object 的，也就是，Vue 是如何拦截拦截对象的 get/set 的。我们知道，用 Object.defineProperty 拦截数据的 get/set 是 vue 的核心逻辑之一。 创建observer劫持数据函数1234567891011function observer (data) &#123; // 如果传进来的数据是一个对象或者空，直接返回 if (typeof data !== &apos;object&apos; || data === null) &#123; return data &#125; // 遍历data for (var key in data) &#123; // 监听数据data defineReactive(data, key, data[key]) &#125;&#125; 创建defineReactive数据监听函数123456789101112131415function defineReactive (target, key, value) &#123; // 如果value是一个对象，则让其回到observer函数 observer(value) Object.defineProperty(target, key, &#123; get () &#123; return value &#125;, set (newValue) &#123; if (newValue !== value) &#123; observer(newValue) // 如果连续修改 并且第二次为对象时 value = newValue &#125; &#125; &#125;)&#125; 那么问题来了，如果劫持到的是一个数组，那么无法监听，因此需要做出以下调整12345678let oldArrayPrototype = Array.prototypelet proto = Object.create(oldArrayPrototype)[&apos;push&apos;, &apos;shift&apos;, &apos;unshift&apos;].forEach((method)=&gt;&#123; proto[method] = function () &#123; update() oldArrayPrototype[method].call(this, ...arguments) &#125;&#125;) 来一个完整版的1234567891011121314151617181920212223242526272829303132333435363738394041let oldArrayPrototype = Array.prototypelet proto = Object.create(oldArrayPrototype)[&apos;push&apos;, &apos;shift&apos;, &apos;unshift&apos;].forEach(method =&gt;&#123; proto[method] = function () &#123; update() oldArrayPrototype[method].call(this, ...arguments) &#125;&#125;)function observer (data) &#123; if (typeof data !== &apos;object&apos; || data === null) &#123; return data &#125; for (var key in data) &#123; defineReactive(data, key, data[key]) &#125;&#125;function defineReactive (target, key, value) &#123; observer(value) Object.defineProperty(target, key, &#123; get () &#123; return value &#125;, set (newValue) &#123; if (newValue !== value) &#123; observer(newValue) // 如果连续修改 并且第二次为对象时 update() value = newValue &#125; &#125; &#125;)&#125;let data = &#123; name: &apos;hello&apos;&#125;function update () &#123; console.log(&apos;更新数据&apos;)&#125;observer(data)data.name = &#123; n: &apos;12&apos; &#125;data.name.n = 1 大功告成，这样就完成了数据的响应式了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[防抖与节流]]></title>
    <url>%2F2020%2F02%2F18%2Fdebounce_throttle%2F</url>
    <content type="text"><![CDATA[如何应用在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 防抖防抖：将几次操作合并为一次操作进行。原理是维护一个计时器，规定在waitTime时间后触发函数，但是在waitTime时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。1234567891011121314151617// 防抖function decounce (fn, waitTime) &#123; var timeout = null return function () &#123; if (timeout !== null) &#123; clearTimeout(timeout) &#125; else &#123; timeout = setTimeout(fn, waitTime) &#125; &#125;&#125;// 处理函数function handle() &#123; console.log(Math.random())&#125;// 滚动事件window.addEventListener(&apos;scroll&apos;, debounce(handle, 1000)); 当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。 节流节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。123456789101112131415function throttle(func, delay) &#123; var timer = null return function () &#123; if (!timer) &#123; timer = setTimeout(function () &#123; func.applay(this, arguments) timer = null &#125;, delay) &#125; &#125;&#125;function handle() &#123; console.log(Math.random())&#125;window.addEventListener(&apos;scroll&apos;, throttle(handle, 1000)) 当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。 区别函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。]]></content>
  </entry>
  <entry>
    <title><![CDATA[TypeScript学习篇]]></title>
    <url>%2F2020%2F01%2F15%2Ftypescript%2F</url>
    <content type="text"><![CDATA[数据类型布尔值(boolean)布尔值有true和false两个值：12let isFalse: boolean = falselet isTrue: boolean = true 数值(number)数值可以是任意进制的值1234let decliteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744; 字符串(string)12let name: string = &apos;bob&apos;;name = &apos;smith&apos;; 还可使用模板字符串，它可以定义多行文本和内嵌表达式。这种字符串是被反引号包围，并且以${expr} 这种形式嵌入表达式。1234let name: string = &apos;Gene&apos;;let age: number = 37;let sentence: string = `Hello, my name is $&#123;name&#125;. I&apos;ll be $&#123;age + 1&#125; years old next month`;console.log(sentence); // Hello, my name is Gene. I&apos;ll be 38 years old next month 数组(array)第一种，可以在元素类型后面接上[],表示由此类型元素组成的一个数组;1let list: number[] = [1,2,3,4]; 第二种，使用数组泛型;12let numbers: Array&lt;number&gt; = [1,2,3];let strings: Array&lt;string&gt; = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]; 元组(tuple)允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。1let x:[string,number] = [&apos;hello&apos;, 10]; 枚举(enum)默认情况下，从0开始为元素编号。你也可以手动的指定成员的数值。123456789enum Color&#123; Red = 3, Green, Blue&#125;let c: Color = Color.Red;console.log(c); // 3let d: Color = Color.blue;console.log(d); // 5 任意类型(any)为那些在编程阶段还不清楚类型的变量指定一个类型。123let notSure: any = 4;notSure = &apos;maybe a string instead&apos;;notSure = false; 无类型(void)某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。当一个函数没有返回值时，使用void。123function warnUser(): void&#123; console.log(&apos;This is my warning message&apos;);&#125; null和undefinedundefined和null两者各自有自己的类型分别叫做undefined和null。和void相似，它们的本身的类型用处不是很大。12let u: undefined = undefined:let n: null = null; 不存在值类型(never)表示那些用不存在的值的类型。never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；变量也可能是never类型，当他额们被永不为真的类型保护所约束时。never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类或可以赋值给never类型。即使any也不能赋值给never。123function error(message: string): never &#123; throw new Error(message);&#125; 函数Function创建方式方式一：1function abc() &#123; ... &#125; 方式二：1function () &#123; .... &#125; 方式三：1let abc = function () &#123; ... &#125; 传参方式传参–可选参数：123function abc(name: string, age?: number):string&#123; return `$&#123;name&#125;---$&#123;age&#125;`;&#125; 传参–默认参数123function abc(name: string, age: number=30):string&#123; return `$&#123;name&#125;---$&#123;age&#125;`&#125; 传参–剩余参数12345678function a(...sum:number[]):number &#123; let su = 0 sum.forEach(item =&gt; &#123; su+= item &#125;) return su&#125;let b = a(1,2,3,4,5) 重载1234567891011function f (name:string):stringfunction f (age:number):numberfunction f (str:any):any &#123; if (typeof str === &apos;string&apos;) &#123; return &apos;我叫&apos; + str &#125; else &#123; return &apos;我的年龄是&apos; + str &#125;&#125;let t = f(22) // 我的年龄是22let t = f(&apos;张三&apos;) // 我叫张三 类定义一个类12345678910111213141516class Person&#123; name: string constructor(name:string)&#123; this.name = name &#125; getName():string&#123; return this.name &#125; setName(name:string):void&#123; this.name = name &#125;&#125;let n = new Person(&apos;张三&apos;);console.log(n.getName()); // 张三n.setName(&apos;李四&apos;);console.log(n.getName()); // 李四 类的继承12345678910111213141516171819class Person&#123; name: string constructor(name:string)&#123; this.name = name &#125; getName():string&#123; return this.name &#125; setName(name:string):void&#123; this.name = name &#125;&#125;class People extends Person &#123; constructor(name:string)&#123; super(name) &#125;&#125;let m = new People(&apos;王老五&apos;)console.log(m.getName()) //王老五 类的多态12345678910111213141516171819202122class Person&#123; name: string constructor(name:string)&#123; this.name = name &#125; getName():string&#123; return this.name &#125; setName(name:string):void&#123; this.name = name &#125;&#125;class People extends Person &#123; constructor(name:string)&#123; super(name) &#125; getName():string &#123; return `$&#123;this.name&#125;--子类` &#125;&#125;let m = new People(&apos;王老五&apos;)console.log(m.getName()) // 王老五--子类 类的修饰符public:共有的，在类里面、子类、类外面都可以访问。protected:保护类型，在类里面、子类里面可以访问，在类外面没法访问。private:私有的，在类里面可以访问，子类、类外部没法访问。 实例方法123456789101112131415class Person&#123; public name: string constructor(name:string)&#123; this.name = name &#125; getName():string&#123; return this.name &#125; setName(name:string):void&#123; this.name = name &#125;&#125;let n = new Person(&apos;张三&apos;)console.log(n.getName())getName与setName必须实例化之后才能调用 静态方法12345678910111213141516class Person&#123; public name: string constructor(name:string)&#123; this.name = name &#125; getName():string&#123; return this.name &#125; setName(name:string):void&#123; this.name = name &#125; static print() &#123; console.log(&apos;静态方法&apos;) &#125;&#125;Person.print() // 静态方法 静态方法无需实例化即可调用,但静态方法无法直接调用类里面的属性,若想调用，可将属性声明为静态属性，static name = ‘李四’。 抽象类提供其他继承的基类，不能直接被实例化。abstract关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。抽象类和抽象方法用来定义标准，在后面类的继承中必须包含某一方法。抽象方法只能用在抽象类中。123456789101112131415161718abstract class Animal &#123; public name: string constructor(name) &#123; this.name = name &#125; abstract eat():any&#125;class Dog extends Animal &#123; constructor(name:string) &#123; super(name) &#125; eat() &#123; console.log(this.name + &apos;吃粮食&apos;) &#125;&#125;var d = new Dog(&apos;小狗&apos;)d.eat()注：如果Dog类中未定义eat方法则会报错 接口在面向对象编程中，接口是一种规范的定义，它定义了行为和动作的规范，在程序设计里面，接口起到一种限制和规范的作用。接口定义了某一批所需要遵循的规范，接口不关心这些类的内部状态数据，也不关心这些类里方法的实现细节，它之规定这批类里必须提供某些方法，提供这些方法的类就可以满足需求。 属性接口：对json约束1234567891011121314interface FullName &#123; firstName: string, secondName: string&#125;function printName(name: FullName) &#123; // 必须传入对象 firstName, secondName console.log(name.firstName + &apos;--&apos; + name.secondName)&#125;var obj = &#123; age: 20, firstName: &apos;张&apos;, secondName: &apos;三&apos;&#125;printName(obj) 可选属性1234567891011121314interface FullName &#123; firstName: string, secondName?: string // 可传可不传&#125;function printName(name: FullName) &#123; // 必须传入对象 firstName console.log(name.firstName + &apos;--&apos; + name.secondName)&#125;var obj = &#123; age: 20, firstName: &apos;张&apos;, secondName: &apos;三&apos;&#125;printName(obj) 函数类型接口1234567interface encrypt&#123; (key: string, value: string):string&#125;var md5:encrypt = function (key: string, value: string):string &#123; return key + value&#125;console.log(md5(&apos;name&apos;,&apos;zhangsan&apos;)) // namezhangsan 可索引接口：数组、对象的约束（不常用）12345interface UserArr&#123; [index:number]:string;&#125;var arr:UserArr = [&apos;aaa&apos;, &apos;123&apos;]console.log(arr[0]) // aaa 类类型接口：对类的约束（常用）12345678910111213141516interface Animal&#123; name: string; eat(str: string):void;&#125;class Dog implements Animal&#123; name: string; constructor(name: string) &#123; this.name = name &#125; eat (food: string) &#123; console.log(this.name + &apos;吃&apos; + food) &#125;&#125;var d = new Dog(&apos;小黑&apos;)d.eat(&apos;粮食&apos;) // 小黑吃粮食注：eat方法可以不用传参，但是必须写。 接口扩展、接口可继承接口123456789101112131415161718192021222324252627282930interface Animal&#123; eat():void&#125;interface Person extends Animal&#123; work():void&#125;class Programmer&#123; public name: string constructor(name: string) &#123; this.name = name &#125; coding () &#123; console.log(this.name + &apos;在写代码&apos;) &#125;&#125;class Web extends Programmer implements Person&#123; constructor (name: string) &#123; super(name) &#125; eat () &#123; console.log(this.name + &apos;馒头&apos;) &#125; work () &#123; console.log(this.name + &apos;在工作&apos;) &#125;&#125;var w = new Web(&apos;小雷&apos;)w.eat() // 小雷馒头w.work() // 小雷在工作w.coding() // 小雷在写代码 注：Animal为主接口，Person为Animal的扩展接口(继承)；Programmer为主类，Web为子类。Web子类继承了Programmer中的属性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[react学习篇]]></title>
    <url>%2F2019%2F12%2F04%2Freact%2F</url>
    <content type="text"><![CDATA[创建react项目方法一：12npm install -g create-react-appcreate-react-app reactdemo 方法二：1npx create-react-app createdemo 进入根目录运行1npm install ,安装依赖后运行1npm run start 即可运行该项目 创建一个组件直接上代码吧12345678910111213141516171819202122232425import React, &#123; Component &#125; from &apos;react&apos;class News extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; mgs: &apos;新闻&apos;, lists: [&apos;111&apos;, &apos;222&apos;, &apos;333&apos;, &apos;444&apos;, &apos;555&apos;, &apos;666&apos;, &apos;777&apos;] &#125; &#125; render() &#123; let lts = this.state.lists.map((item, key) =&gt; &#123; return &lt;li key=&#123;key&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) return( &lt;div&gt; &lt;h1&gt;&#123;this.state.mgs&#125;&lt;/h1&gt; &lt;ul&gt; &#123;lts&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default News; 然后在app.js中注册该组件就可以啦 绑定数据react的数据绑定是使用单花括号，如下：12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;;class Home extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; msg: &apos;我是一个home组件&apos; &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;&#123;this.state.msg&#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;export default Home; 绑定属性方法一：使用1style=&#123;&#123;&apos;属性名&apos;: &apos;属性值&apos;&#125;&#125; （不推荐）。12345678910111213141516171819202122import React, &#123; Component &#125; from &apos;react&apos;;import &apos;../assets/css/index.css&apos;class Home extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; msg: &apos;我是一个home组件&apos;, title: &apos;我是一个title&apos;, color: &apos;orange&apos; &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;div style=&#123;&#123;&apos;color&apos;: &apos;#0ff&apos;&#125;&#125;&gt;我是一个stylediv&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Home; 方法二：首先从外部引入css文件，使用className属性。123456789101112131415161718192021222324import React, &#123; Component &#125; from &apos;react&apos;;import &apos;../assets/css/index.css&apos;class Home extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; msg: &apos;我是一个home组件&apos;, title: &apos;我是一个title&apos;, color: &apos;orange&apos; &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;&#123;this.state.msg&#125;&lt;/h2&gt; &lt;div title=&#123;this.state.title&#125;&gt;我是一个div&lt;/div&gt; &lt;div className=&quot;red&quot;&gt;我是一个红色div&lt;/div&gt; &lt;div className=&#123;this.state.color&#125;&gt;我是一个橙色div&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Home; 遍历直接上代码吧：123456789101112131415161718192021222324import React, &#123; Component &#125; from &apos;react&apos;;class News extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; lists: [&apos;111&apos;, &apos;222&apos;, &apos;333&apos;, &apos;444&apos;, &apos;555&apos;, &apos;666&apos;, &apos;777&apos;] &#125; &#125; render() &#123; let lts = this.state.lists.map((item, key) =&gt; &#123; return &lt;li key=&#123;key&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) return( &lt;div&gt; &lt;ul&gt; &#123;lts&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default News; 事件绑定1、不获取数据的事件1234567891011121314151617181920212223import React, &#123; Component &#125; from &apos;react&apos;;class events extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; msg: &apos;事件组件&apos; &#125; &#125; run() &#123; alert(&apos;我是一个run方法&apos;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.run&#125;&gt;点我&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default events; 2、需获取数据的事件方法一：通过bind123456789101112131415161718192021222324252627import React, &#123; Component &#125; from &apos;react&apos;;class events extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; msg: &apos;事件组件&apos; &#125; &#125; run() &#123; alert(&apos;我是一个run方法&apos;) &#125; getDate() &#123; alert(this.state.msg) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.run&#125;&gt;点我&lt;/button&gt; &lt;button onClick=&#123;this.getDate.bind(this)&#125;&gt;获取数据---第一种改变this指向&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default events; 方法二：使用箭头函数（此方法较常用）12345678910111213141516171819202122232425import React, &#123; Component &#125; from &apos;react&apos;;class events extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; msg: &apos;事件组件&apos;, message: &apos;我是一个message&apos;, userName: &apos;itying&apos; &#125; &#125; getName = () =&gt; &#123; alert(this.state.userName) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.getName&#125;&gt;获取数据---第三种改变this指向&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default events; 3、改变数据中值的事件123456789101112131415161718192021222324252627import React, &#123; Component &#125; from &apos;react&apos;;class events extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; msg: &apos;事件组件&apos;, message: &apos;我是一个message&apos;, userName: &apos;itying&apos; &#125; &#125; changeName = () =&gt; &#123; this.setState(&#123; msg: &apos;我是改变后的值&apos; &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.changeName&#125;&gt;改变数据&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default events; 4、事件中带有参数123456789101112131415161718192021222324252627import React, &#123; Component &#125; from &apos;react&apos;;class events extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; msg: &apos;事件组件&apos;, message: &apos;我是一个message&apos;, userName: &apos;itying&apos; &#125; &#125; paramsName = (str) =&gt; &#123; this.setState(&#123; msg: str &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.paramsName.bind(this,&apos;我是事件传过来的值&apos;)&#125;&gt;传值&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default events; 父子组件通信父组件不仅可以给子组件传值，还可以给子组件传递方法甚至整个父组件的内容，如下：父组件：12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from &apos;react&apos;;import Header from &apos;./Header&apos;class Newss extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; msg: &apos;我是新闻组件的内容&apos;, title: &apos;新闻组件&apos; &#125; &#125; run = () =&gt; &#123; alert(&quot;我是父组件run方法&quot;) &#125; getData = () =&gt; &#123; alert(this.state.title) &#125; render() &#123; return ( &lt;div&gt; &lt;Header title=&#123;this.state.title&#125; run=&#123;this.run&#125; news=&#123;this&#125;&gt;&lt;/Header&gt; &#123;this.state.msg&#125; &lt;/div&gt; ); &#125;&#125;export default Newss; 子组件：1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &apos;react&apos;;class Header extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; msg: &apos;这是头部组件&apos; &#125; &#125; getNews = () =&gt; &#123; alert(this.props.news.state.msg) &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.msg&#125; &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.props.run&#125;&gt;调用newss父组件中的方法&lt;/button&gt; &lt;button onClick=&#123;this.props.news.getData&#125;&gt;获取newss组件getData方法&lt;/button&gt; &lt;button onClick=&#123;this.getNews&#125;&gt;获取newss组件实例&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default Header; 父组件主动获取子组件中的数据：1.调用子组件时指定ref的值 2.通过this.refs.footer获取整个子组件实例。父组件：1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &apos;react&apos;;import Footer from &apos;./Footer&apos;class Newss extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; msg: &apos;我是新闻组件的内容&apos;, title: &apos;新闻组件&apos; &#125; &#125; getFooter = () =&gt; &#123; alert(this.refs.footer.state.msg) this.refs.footer.run() &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.getFooter&#125;&gt;获取整个子组件&lt;/button&gt; &lt;Footer ref=&quot;footer&quot;&gt;&lt;/Footer&gt; &lt;/div&gt; ); &#125;&#125;export default Newss; 子组件：12345678910111213141516171819202122import React, &#123; Component &#125; from &apos;react&apos;;class Footer extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; msg: &quot;我是一个底部组件&quot; &#125; &#125; run = () =&gt; &#123; alert(&quot;我是底部组件的run方法&quot;) &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;我是一个底部组件&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;export default Footer; 双向数据绑定123456789101112131415161718192021222324import React, &#123; Component &#125; from &apos;react&apos;;class form extends Component &#123; constructor(props)&#123; super(props) this.state = &#123; username: &apos;1111&apos; &#125; &#125; handleUsername = (e) =&gt; &#123; this.setState(&#123; username: e.target.value &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;React 表单&lt;/h1&gt; &lt;input type=&apos;text&apos; value=&#123;this.state.username&#125; onChange=&#123;this.handleUsername&#125;&gt;&lt;/input&gt;&#123;this.state.username&#125; &lt;/div&gt; ); &#125;&#125;export default form; 注：value绑定username时必须监听onChange事件，如果不想监听onChange事件则需将value改成defaultValue（原生input中的value）；因此：如果想获取值并且改变值用value+onChange;如果只想获取值则用defaultValue。 react如何向服务器发送请求react中没有提供专门的请求数据模块，只能使用第三方请求数据模块数显请求数据。方法一：axios安装axios模块：npm install axios –save;引入axios（在哪儿使用在哪儿引入）：import axios from ‘axios’;12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from &apos;react&apos;;import axios from &apos;axios&apos;class Axios extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; msg: &apos;数据请求&apos;, list: [] &#125; &#125; getDate = () =&gt; &#123; var api = &apos;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&apos; axios.get(api).then(res =&gt; &#123; console.log(res) this.setState(&#123; list: res.data.result &#125;) &#125;) &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.msg&#125; &lt;h2&gt;axios获取服务器数据&lt;/h2&gt; &lt;button onClick=&#123;this.getDate&#125;&gt;获取服务器数据&lt;/button&gt; &lt;hr /&gt; &lt;ul&gt; &#123; this.state.list.map((item,key) =&gt; &#123; return &lt;li key=&#123;key&#125;&gt;&#123;item.title&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;export default Axios; 方法二：fetch-jsonp安装fetch-jsonp：npm install fetch-jsonp –save;引入fetch-jsonp（在哪儿使用在哪儿引入）：import FetchJsonp from ‘fetch-jsonp’;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component &#125; from &apos;react&apos;;import fetchJsonp from &apos;fetch-jsonp&apos;class FetchJsonp extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; list: [] &#125; &#125; fetch = () =&gt; &#123; var api = &apos;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&apos; fetchJsonp(api) .then((response) =&gt; &#123; return response.json() &#125;).then((json) =&gt; &#123; console.log(&apos;parsed json&apos;, json) this.setState(&#123; list: json.result &#125;) &#125;).catch(function(ex) &#123; console.log(&apos;parsing failed&apos;, ex) &#125;) &#125; clearData = () =&gt; &#123; this.setState(&#123; list: [] &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Fetch-Jsonp&lt;/h2&gt; &lt;button onClick=&#123;this.fetch&#125;&gt;获取fetch-jsonp数据&lt;/button&gt; &lt;button onClick=&#123;this.clearData&#125;&gt;清除&lt;/button&gt; &lt;hr/&gt; &lt;ul&gt; &#123; this.state.list.map((item,key) =&gt; &#123; return &lt;li key=&#123;key&#125;&gt;&#123;item.title&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;export default FetchJsonp; react生命周期生命周期：组件加载前、组件加载完成、组件更新数据、组件销毁所触发的一系列方法。1、组件加载的时候触发的生命周期函数：constructor、render、componentWillMount、componentDidMount123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import React, &#123; Component &#125; from &apos;react&apos;;import axios from &apos;axios&apos;class Axios extends Component &#123; constructor(props) &#123; console.log(&apos;构造函数---01&apos;) super(props) this.state = &#123; msg: &apos;数据请求&apos;, list: [] &#125; &#125; getDate = () =&gt; &#123; var api = &apos;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&apos; axios.get(api).then(res =&gt; &#123; console.log(res) this.setState(&#123; list: res.data.result &#125;) &#125;) &#125; clearData = () =&gt; &#123; this.setState(&#123; list: [] &#125;) &#125; // 组件将要挂载时触发的生命周期函数 componentWillMount () &#123; console.log(&apos;组件将要挂载--02&apos;) &#125; // 组件挂载完成时触发的生命周期函数（dom操作、请求数据） componentDidMount () &#123; console.log(&apos;组件将要挂载--04&apos;) this.getDate() &#125; render() &#123; console.log(&apos;数据渲染--03&apos;) return ( &lt;div&gt; &#123;this.state.msg&#125; &lt;h2&gt;axios获取服务器数据&lt;/h2&gt; &lt;button onClick=&#123;this.getDate&#125;&gt;获取服务器数据&lt;/button&gt; &lt;button onClick=&#123;this.clearData&#125;&gt;清除&lt;/button&gt; &lt;hr /&gt; &lt;ul&gt; &#123; this.state.list.map((item,key) =&gt; &#123; return &lt;li key=&#123;key&#125;&gt;&#123;item.title&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;export default Axios; 2、组件更新的时候触发的生命周期函数：shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, &#123; Component &#125; from &apos;react&apos;;import axios from &apos;axios&apos;class Axios extends Component &#123; constructor(props) &#123; console.log(&apos;构造函数---01&apos;) super(props) this.state = &#123; msg: &apos;数据请求&apos;, list: [] &#125; &#125; getDate = () =&gt; &#123; var api = &apos;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&apos; axios.get(api).then(res =&gt; &#123; console.log(res) this.setState(&#123; list: res.data.result &#125;) &#125;) &#125; clearData = () =&gt; &#123; this.setState(&#123; list: [] &#125;) &#125; setMsg = () =&gt; &#123; this.setState(&#123; msg: &apos;我是改变后的值&apos; &#125;) &#125; // 是否执行更新生命周期函数 shouldComponentUpdate (nextProps, nextState) &#123; console.log(&apos;01是否要更新数据&apos;) console.log(nextProps,nextState) return true // 只有返回ture的时候才会执行后面两个生命周期函数 &#125; componentWillUpdate () &#123; console.log(&apos;02组件将要更新&apos;) &#125; componentDidUpdate () &#123; console.log(&apos;04组件更新完成&apos;) &#125; render() &#123; console.log(&apos;数据渲染--03&apos;) return ( &lt;div&gt; &#123;this.state.msg&#125; &lt;h2&gt;生命周期函数演示--&#123;this.state.msg&#125;&lt;/h2&gt; &lt;button onClick=&#123;this.getDate&#125;&gt;获取服务器数据&lt;/button&gt; &lt;button onClick=&#123;this.clearData&#125;&gt;清除&lt;/button&gt; &lt;button onClick=&#123;this.setMsg&#125;&gt;更新msg数据&lt;/button&gt; &lt;hr /&gt; &lt;ul&gt; &#123; this.state.list.map((item,key) =&gt; &#123; return &lt;li key=&#123;key&#125;&gt;&#123;item.title&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;export default Axios; 3、在父组件里面改变props传值的时候触发：componentWillReceiveProps4、组件销毁的时候触发：componentWillUnmount必须记住的生命周期函数：加载的时候：componentWillMount、render、componentDidMount;更新的时候：componentWillUpdate、render、componentDidUpdate;销毁的时候：componentWillUnmount。 路由与路由跳转以及传参添加插件：npm install –save react-router-dom 配置路由123456789101112131415161718192021// 在App.js文件中设置import Jsdemoa from &apos;./components/Jsdemo&apos;import Jsdemob from &apos;./components/Jsdemob&apos;import Jsdemoc from &apos;./components/Jsdemoc&apos;import &#123; HashRouter as Router,Route&#125; from &apos;react-router-dom&apos;import React, &#123; Component &#125; from &apos;react&apos;;class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;Route path=&quot;/&quot; exact=&#123;true&#125; component=&#123;Jsdemoa&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;/demob&quot; component=&#123;Jsdemob&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;/democ&quot; component=&#123;Jsdemoc&#125;&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App; exact 表示严格匹配 路由跳转方法一：html跳转1234567891011121314151617import React, &#123; Component &#125; from &apos;react&apos;;import &#123; Link &#125; from &apos;react-router-dom&apos;class Jsdemo extends Component &#123; render() &#123; return ( &lt;div id=&quot;app&quot;&gt; Jsdemoa &lt;div&gt; &lt;Link to=&quot;/demob&quot;&gt;jumpToDemob&lt;/Link&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Jsdemo; 方式二：js跳转12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;;class Jsdemo extends Component &#123; jumpToDemob = () =&gt; &#123; this.props.history.push(&apos;/demob&apos;) &#125; render() &#123; return ( &lt;div id=&quot;app&quot;&gt; Jsdemoa &lt;div&gt; &lt;button onClick=&#123;this.jumpToDemob&#125;&gt;jumpToDemob&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Jsdemo; 路由传参params传参1.在配置路由时设置跳转时需要传递的参数 2.根据路由所设置的参数传参this.props.history.push(‘/demob/张三’)在被跳转页面使用this.props.match.params.XXX接受参数 query传参在跳转时 路径为一个对象{} 其中 pathname为路径 query为一个对象 对象里是携带的参数1this.props.history.push(&#123;pathname:&apos;/demob&apos;,query: &#123;name: &apos;jack&apos;,age: 18&#125;&#125;) 在被跳转页面使用this.props.location.query接收参数 state传参在跳转时 路径为一个对象{} 其中 pathname为路径 state为一个对象 对象里是携带的参数1this.props.history.push(&#123;pathname:&apos;/demob&apos;,state: &#123;name: &apos;jack&apos;,age: 18&#125;&#125;) 在被跳转页面使用this.props.location.state接收参数 动态路由传参配置路由时：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152组件中：import React, &#123; Component &#125; from &apos;react&apos;;import &#123;Link&#125; from &apos;react-router-dom&apos;class Product extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; msg: &apos;我是产品组件&apos;, // date: new Date(), list: [ &#123; name: &apos;adis&apos;, price: &apos;1133&apos; &#125;, &#123; name: &apos;sess&apos;, price: &apos;2233&apos; &#125;, &#123; name: &apos;serr&apos;, price: &apos;3333&apos; &#125;, &#123; name: &apos;eeee&apos;, price: &apos;4444&apos; &#125; ] &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;hr /&gt; &lt;ul&gt; &#123; this.state.list.map((item,key) =&gt; &#123; return ( &lt;li key=&#123;key&#125;&gt; &lt;Link to=&#123;`/content/$&#123;item.price&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt; &lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;export default Product; 传过来的值用接收传过来的值：this.props.match.params.price 路由嵌套核心：在需要的页面引入相应的组件与路由配置即可实现路由嵌套父组件：1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from &apos;react&apos;;import &apos;../assets/css/firstPage.css&apos;import &#123; Route, Link&#125; from &apos;react-router-dom&apos;import Info from &apos;./user/Info&apos;import Main from &apos;./user/Main&apos;class User extends Component &#123; constructor(props) &#123; super(props) this.state=&#123; msg:&apos;用户中心组件&apos; &#125; &#125; render() &#123; return ( &lt;div className=&quot;content&quot;&gt; &lt;div className=&quot;left&quot;&gt; &lt;Link to=&quot;/user/info&quot;&gt;用户信息&lt;/Link&gt; &lt;br&gt;&lt;/br&gt; &lt;br&gt;&lt;/br&gt; &lt;Link to=&quot;/user&quot;&gt;个人中心&lt;/Link&gt; &lt;/div&gt; &lt;div className=&quot;right&quot;&gt; &lt;Route path=&quot;/user/info&quot; component=&#123;Info&#125;&gt;&lt;/Route&gt; &lt;Route exact path=&quot;/user&quot; component=&#123;Main&#125;&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default User; 子组件1：12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;;class Info extends Component &#123; constructor(props) &#123; super(props) this.state=&#123; msg: &apos;我是个人信息组件&apos; &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default Info; 子组件2：1234567891011121314151617181920import React, &#123; Component &#125; from &apos;react&apos;;class Main extends Component &#123; constructor(props) &#123; super(props) this.state=&#123; msg: &apos;我是个人中心组件&apos; &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default Main;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS预处理器--LESS篇]]></title>
    <url>%2F2019%2F09%2F09%2Fless%2F</url>
    <content type="text"><![CDATA[LESSLess 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。Less 可以运行在 Node、浏览器和 Rhino 平台上。网上有很多第三方工具帮助你编译 Less 源码。 如何在vue项目中使用less1.安装less依赖：npm install less less-loader --save2.在build/webpack.base.conf.js文件中:在module的rules添加如下配置：1234&#123; test: /\/less$/, loader: &quot;style-loader!css-loader!less-loader&quot;&#125; 3.在style标签上添加lang属性，指定使用的样式语法:&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt;配置文成，这样就可以在vue项目中使用less啦。 变量普通变量less 以@开头定义变量，并且使用时直接键入@名称。注意：作为属性值的变量不能添加大括号1234@color:#333;.container&#123; Background：@color；&#125; 注意：Less其变量只能定义一次，不能重复定义，否则后面的会类似与js的变量提升，覆盖前面的变量 选择器变量选择器变量，让选择器变成一个动态的。作为选择器的变量在使用的时候需要添加大括号，变量的前面可以添加选择操作符。1234567891011121314151617181920212223@mySelector: #wrap;@Wrap: wrap;@&#123;mySelector&#125;&#123; //变量名 必须使用大括号包裹 color: #999; width: 50%;&#125;.@&#123;Wrap&#125;&#123; color:#ccc;&#125;#@&#123;Wrap&#125;&#123; color:#666;&#125; /* 生成的 CSS */#wrap&#123; color: #999; width: 50%;&#125;.wrap&#123; color:#ccc;&#125;#wrap&#123; color:#666;&#125; 属性变量可以在书写的时候少写很多内容，属性变量使用的时候也需要添加大括号123456789@borderStyle: border-style;@Soild:solid;#wrap&#123; @&#123;borderStyle&#125;: @Soild;//变量名 必须使用大括号包裹&#125;/* 生成的 CSS */#wrap&#123; border-style:solid;&#125; url变量项目结构改变时，可以方便我们修改，目的是为了方便项目的维护12345678@images: &quot;../img&quot;;//需要加引号body &#123; background: url(&quot;@&#123;images&#125;/dog.png&quot;);//变量名 必须使用大括号包裹&#125;/* 生成的 CSS */body &#123; background: url(&quot;../img/dog.png&quot;);&#125; 声明变量定义：@name：{ Key：value； Key：value；}12345678910111213141516171819202122@background: &#123;background:red;&#125;;#main&#123; @background();&#125;@Rules:&#123; width: 200px; height: 200px; border: solid 1px red;&#125;;#con&#123; @Rules();&#125;/* 生成的 CSS */#main&#123; background:red;&#125;#con&#123; width: 200px; height: 200px; border: solid 1px red;&#125; 变量运算加减法时，以第一个数据的单位为基准；乘除法时，注意单位一定要统一1234567891011121314151617@width:300px;@color:#222;#wrap&#123; width:@width-20; height:@width-20*5; margin:(@width-20)*5; color:@color*2; background-color:@color + #111;&#125;/* 生成的 CSS */#wrap&#123; width:280px; height:200px; margin:1400px; color:#444; background-color:#333;&#125; 使用变量定义变量解析的顺序是从后向前逐层解析123456789@fnord: &quot;I am fnord.&quot;;@var: &quot;fnord&quot;;#wrap::after&#123; content: @@var; //将@var替换为其值 content:@fnord;&#125;/* 生成的 CSS */#wrap::after&#123; content: &quot;I am fnord.&quot;;&#125; 嵌套&amp;符号，表示的是上1级选择器的名字。123456789101112131415161718192021#header&#123; &amp;:after&#123; //注意：不能省略&amp;，如果省略会给每一个子元素添加一个after。 content:&quot;Less is more!&quot;; &#125; .title&#123; font-weight:bold; &#125; &amp;_content&#123;//理解方式：直接把 &amp; 替换成 #header margin:20px; &#125;&#125;/* 生成的 CSS */#header::after&#123; content:&quot;Less is more!&quot;;&#125;#header .title&#123; //嵌套了 font-weight:bold;&#125;#header_content&#123;//没有嵌套！ margin:20px;&#125; 嵌套覆盖原有样式1234567891011div&#123; width:200px; height:200px; background:red; .show&#123; display: none; &#125;&#125;.show&#123; display: block; //被覆盖，只有在div使用show时才覆盖&#125; 混合方法具体参数方法less可以传递参数1234.setSize(@width_size,@height_size)&#123; width:@width_size; height:@height_size;&#125; 默认参数法默认参数方法：Less 可以使用默认参数，如果没有传参数，那么将使用默认参数。 @arguments 犹如 JS 中的 arguments 指代的是全部参数。 传的参数中 必须带着单位。123456789101112131415161718192021222324252627.border(@a:10px,@b:50px,@c:30px,@color:#000)&#123; border:solid 1px @color; box-shadow: @arguments;//指代的是 全部参数&#125;#main&#123; .border(0px,5px,30px,red);//必须带着单位&#125;#wrap&#123; .border(0px);&#125;#content&#123; .border;//等价于 .border()&#125;/* 生成的 CSS */#main&#123; border:solid 1px red; box-shadow:0px,5px,30px,red;&#125;#wrap&#123; border:solid 1px #000; box-shadow: 0px 50px 30px #000;&#125;#content&#123; border:solid 1px #000; box-shadow: 10px 50px 30px #000;&#125; 不定参不确定参数的个数123456789101112131415.boxShadow(...)&#123; box-shadow: @arguments;&#125;.textShadow(@a,...)&#123; text-shadow: @arguments;&#125;#main&#123; .boxShadow(1px,4px,30px,red); .textShadow(1px,4px,30px,red);&#125;/* 生成后的 CSS */#main&#123; box-shadow: 1px 4px 30px red; text-shadow: 1px 4px 30px red;&#125; 方法的匹配模式方法的匹配模式：同一个方法名的多个方法，由于传入的参数不同而实现的不同功能1234567891011121314151617181920212223242526.triangle(top,@width:20px,@color:#000)&#123; border-color:transparent transparent @color transparent ;&#125;.triangle(right,@width:20px,@color:#000)&#123; border-color:transparent @color transparent transparent ;&#125;.triangle(bottom,@width:20px,@color:#000)&#123; border-color:@color transparent transparent transparent ;&#125;.triangle(left,@width:20px,@color:#000)&#123; border-color:transparent transparent transparent @color;&#125;.triangle(@_,@width:20px,@color:#000)&#123; border-style: solid; border-width: @width;&#125;#main&#123; .triangle(left, 50px, #999)&#125;/* 生成的 CSS */#main&#123; border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px;&#125; 方法的命名空间在 CSS 中&gt; 选择器，选择的是儿子元素，就是必须与父元素有直接血源的元素。 - 在引入命令空间时，如使用 &gt; 选择器，父元素不能加括号。 - 不得单独使用命名空间的方法必须先引入命名空间，才能使用其中方法。 - 子方法可以使用上一层传进来的方法。1234567891011121314151617.div&#123; background:red; .size(@width)&#123; width:@width; height:200px; border:1px solid #ccc; .a(@height)&#123; height:@height; width:@width; &#125; &#125;&#125;a&#123; display: block; .div&gt;.size(200px); .a(200px);&#125; 继承(扩展)extend是less的一个伪类。它可以继承所匹配声明中的全部样式。1234567891011121314151617181920.animation&#123; transition: all .3s ease-out; .hide&#123; transform:scale(0); &#125;&#125;#main&#123; &amp;:extend(.animation);&#125;#con&#123; &amp;:extend(.animation .hide);&#125;/* 生成后的 CSS */.animation,#main&#123; transition: all .3s ease-out;&#125;.animation .hide , #con&#123; transform:scale(0);&#125; all全局搜索替换1234567891011121314151617#main&#123; width: 200px;&#125;#main &#123; &amp;:after &#123; content:&quot;Less is good!&quot;; &#125;&#125;#wrap:extend(#main all) &#123;&#125;/* 生成的 CSS */#main,#wrap&#123; width: 200px;&#125;#main:after, #wrap:after &#123; content: &quot;Less is good!&quot;;&#125; 导入导入less文件，可以省略后缀12import “index.less”;import “index”;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS预处理器--SCSS篇]]></title>
    <url>%2F2019%2F08%2F26%2Fscss%2F</url>
    <content type="text"><![CDATA[什么是CSS预处理器CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，“CSS 预处理器用一种专门的编程语言，进行Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题”，例如你可以在CSS 中使用变量、简单的逻辑程序、函数等等。到目前为止，在众多优秀的CSS预处理器语言中就属Sass、LESS和Stylus最优秀，讨论的也多，对比的也多。本文将着重介绍SCSS。 SCSSSass是成熟、稳定、强大的CSS预处理器，而SCSS是Sass3版本当中引入的新语法特性，完全兼容CSS3的同时继承了Sass强大的动态功能。 变量用来存储需要在CSS中复用的信息，例如颜色和字体。SASS通过$符号去声明一个变量。123456$primary-background: #0ff;$primary-color: #333;body &#123; background: $primary-background; color: $primary-color;&#125; 嵌套SASS允许开发人员以嵌套的方式使用CSS，但是过度的使用嵌套会让产生的CSS难以维护，因此使用嵌套时，嵌套的层数不能太多。123456789101112131415.unorderList &#123; ul &#123; margin: 0; padding: 0; list-style: none; li &#123; display: inline-block; &#125; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; 以上代码经过编译后会成为如下格式12345678910111213.unorderList&gt;ul &#123; margin: 0; padding: 0; list-style: none;&#125;.unorderList&gt;ul&gt;li &#123; display: inline-block;&#125;.unorderList&gt;a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; 混合混合（Mixin）用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。123456789@mixin border-radius($radius) &#123; border-radius: $radius; -ms-border-radius: $radius; -moz-border-radius: $radius; -webkit-border-radius: $radius;&#125;.box &#123; @include border-radius(10px);&#125; 上面的代码建立了一个名为border-radius的Mixin，并传递了一个变量$radius作为参数，然后在后续代码中通过@include border-radius(10px)使用该Mixin，最终编译的结果如下:123456.box &#123; border-radius: 10px; -ms-border-radius: 10px; -moz-border-radius: 10px; -webkit-border-radius: 10px;&#125; 继承继承是SASS中非常重要的一个特性，可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码，下面例子将会通过SASS提供的继承机制建立一系列样式：1234567891011121314151617181920212223242526// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。%other-styles &#123; display: flex; flex-wrap: wrap;&#125;// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。%message-common &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.message &#123; @extend %message-common;&#125;.success &#123; @extend %message-common; border-color: green;&#125;.error &#123; @extend %message-common; border-color: red;&#125;.warning &#123; @extend %message-common; border-color: yellow;&#125; 上面代码将.message中的CSS属性应用到了.success、.error、.warning上面，魔法将会发生在最终生成的CSS当中。这种方式能够避免在HTML元素上书写多个class选择器，最终生成的CSS样式是下面这样的：1234567891011121314.message, .success, .error, .warning &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.success &#123; border-color: green;&#125;.error &#123; border-color: red;&#125;.warning &#123; border-color: yellow;&#125; 操作符SASS提供了标准的算术运算符，例如+、-、*、/、%。在接下来的例子里，我们尝试在aside和article选择器当中对宽度进行简单的计算。123456789101112.container &#123; width: 100%; height: 100%;&#125;.article &#123; float: left; width: 600px / 960px * 100%;&#125;.aside &#123; float: right; width: 300px / 960px * 100%;&#125; 上面代码以960px为基准建立了简单的流式网格布局，SASS提供的算术运算符让开发人员可以更容易的将像素值转换为百分比，最终生成的CSS样式如下所示：1234567891011.container &#123; width: 100%;&#125;article[role=&quot;main&quot;] &#123; float: left; width: 62.5%;&#125;aside[role=&quot;complementary&quot;] &#123; float: right; width: 31.25%;&#125; 引用父级选择器”&amp;”Scss使用”&amp;”关键字在CSS规则中引用父级选择器，例如在嵌套使用伪类选择器的场景下：123456789101112131415161718/*===== SCSS =====*/a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; text-decoration: underline; &#125; body.firefox &amp; &#123; font-weight: normal; &#125;&#125;/*===== CSS =====*/a &#123; font-weight: bold; text-decoration: none;&#125;a:hover &#123; text-decoration: underline;&#125;body.firefox a &#123; font-weight: normal;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[在SPA项目中，如何修改网页的标题(VUE专题)]]></title>
    <url>%2F2019%2F07%2F29%2FhowToUpdateWebTitel%2F</url>
    <content type="text"><![CDATA[什么是SPA单页面Web应用（single page web application,SPA）：SPA是一种特殊的web应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面。它将所有活动局限于一个web页面中，仅在该web页面初始化时加载相应的HTML、JavaScript、css。一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或者跳转，而是利用JavaScript动态的变换HTML（采用的是div切换显示和隐藏），从而实现UI与用户的交互。在SPA应用中，应用加载之后就不会再有整页刷新。相反，展示逻辑预先加载，并有赖于内容Region(区域)中的视图切换来展示内容。 导航钩子比较理想的一个思路就是，在页面发生路由改变时，统一设置。vue-router提供了导航钩子beforeEach和afterEach，它们会在路由即将改变前和改变后触发，所以设置标题可以在beforeEach钩子完成。在main.js文件中12345const router = new VueRouter(RouterConfig)router.beforeEach((to, from, next) =&gt; &#123; window.document.title = to.meta.title next()&#125;) 导航钩子有三个参数：1.to: 即将要进入的目标的路由对象。2.from: 当前导航即将要离开的路由对象。3.next: 调用该方法后，才能进入下一个钩子。 页面较长，滚动到某一个位置跳转到另一个页面时停在顶端main.js文件中123router.afterEach((to, from, next) =&gt; &#123; windom.scrollTo(0,0)&#125;) 页面需要校验是否登录某些页面需要校验是否登录，如果登陆了就可以访问，否则跳转到登陆页。这里我们通过localStorage来简易判断是否登录1234567router.beforeEach((to, from, next) =&gt; &#123; if (windom.localStorage.getItem(&apos;token&apos;)) &#123; next() &#125; else &#123; next(&apos;/login&apos;) &#125;&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[懒加载和预加载]]></title>
    <url>%2F2019%2F05%2F13%2FCSS_lazyLoad%2F</url>
    <content type="text"><![CDATA[懒加载什么是懒加载懒加载也就是延迟加载。当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次，俗称占位图），只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。 懒加载的原理页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有设置了src图片路径，浏览器才会发送请求。懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把正真的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置； 如何实现1、通过css实现1&lt;img src=&quot;***.png&quot; lazy=&quot;loaded&quot;&gt;&lt;/img&gt; 2、通过js实现1234&lt;img src=&quot;***.png&quot; id=&quot;setLazy&quot;&gt;&lt;/img&gt;&lt;script&gt;document.getElementById(&quot;setLazy&quot;).style.lazy = loaded&lt;/script&gt; 懒加载的优点1、页面加载速度快2、可以减轻服务器的压力3、节约了流量,用户体验好 预加载什么是预加载提前加载图片，当用户需要查看时可直接从本地缓存中渲染，这就是预加载 为什么要使用预加载图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。 实现预加载的方法1、用CSS和JavaScript实现预加载2、仅使用JavaScript实现预加载3、使用Ajax实现预加载 懒加载和预加载的对比1.概念：懒加载也叫延迟加载：JS图片延迟加载,延迟加载图片或符合某些条件时才加载某些图片。预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。2.区别：懒加载会延迟加载图片，预加载会提前加载图片懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 模块化懒加载在一个项目中，当我们点击一个页面时才会加载相关模块。实现模块化懒加载的方式：1、import：123456789&#123; path: &apos;/login&apos;, name: &apos;login&apos;, meta: &#123; title: &apos;登录&apos;, hideInMenu: true &#125;, component: () =&gt; import(&apos;@/components/login/login-form.vue&apos;)&#125; 2、resolve:123456789&#123; path: &apos;/login&apos;, name: &apos;login&apos;, meta: &#123; title: &apos;登录&apos;, hideInMenu: true &#125;, component: require.ensure([], () =&gt; resolve(require(&apos;@/components/login/login-form.vue&apos;)))&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[字符串、数组方法汇总]]></title>
    <url>%2F2019%2F05%2F10%2FJS_Array_API%2F</url>
    <content type="text"><![CDATA[数组的方法(api)1、join()将数组转为字符串，可以按照指定的字符来拼接数组之间的元素12var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];console.log(arr.join(&apos;@&apos;));// &apos;a@b@c&apos; 2、concat()合并多个数组中的元素123var arr1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var arr2 = [&apos;d&apos;,&apos;e&apos;,&apos;f&apos;];console.log(arr1.concat(arr2));// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 3、slice(start,end)截取数组中的元素，start开始的下标，end结束的下标，不包含结束的下标；如果end为空，截取到最后。12var arr1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;];console.log(arr1.slice(1,3));// [&quot;b&quot;, &quot;c&quot;] 4、splice(start,count,value1,value2…)删除数组中的元素；start开始删除的下标，count删除的数量，value1…删除后添加的元素；如果count为空表示从下标开始删除到最后。123var arr1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;];console.log(arr1.splice(1,3,a,b));// [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]console.log(arr1);// [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;e&quot;] 5、reverse()翻转数组中的元素12var arr1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];console.log(arr1.reverse());// [&quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;] 6、sort()对数组元素排序，默认按照Unicode码由小到大排序1234sort(function(a,b)&#123; return a-b; //数字由小到大 return b-a; //数字由大到小 &#125;) 7、push()在数组的最后添加元素，返回数组的长度123var arr1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];console.log(arr1.push(&apos;e&apos;));// 5console.log(arr1);// [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;] 8、pop()删除数组中的最后一个元素，返回删除的元素123var arr1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];console.log(arr1.pop());// dconsole.log(arr1);// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 9、unshift()在数组的开头添加元素，返回数组的长度123var arr1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];console.log(arr1.unshift(&apos;e&apos;));// 5console.log(arr1);// [&quot;e&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 10、shift()删除数组中的第一个元素，返回删除的元素123var arr1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];console.log(arr1.shift());// aconsole.log(arr1);// [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 字符串的方法(api)1、toUpperCase()英文字符转为大写12var str = &quot;abcdefg&quot;;console.log(str.toUpperCase());// ABCDEFG 2、toLowerCase()英文字符转为小写12var str = &quot;ABCDEFG&quot;;console.log(str.toLowerCase());// abcdefg 3、charAt()获取下标对应的字符12var str = &quot;abcdefg&quot;;console.log(str.charAt(3)); // d 4、charCodeAt()将某个字符转为Unicode码12var str = &quot;a&quot;;console.log(str.charCodeAt()); // 97 5、indexOf(value,start)查找某个字符(串)对应的下标；value要查找的字符(串)，start开始查找的下标，默认是0；找不到返回-1.12var str = &quot;abcdefgd&quot;;console.log(str.indexOf(&quot;d&quot;,2));// 3 6、lastIndexOf(value)倒着查找某一个字符，value要查找的字符12var str = &quot;abcdefgd&quot;;console.log(str.lastIndexOf(&quot;d&quot;));// 7 7、slice(start,end)截取字符串，start开始的下标，end结束的下标，不包含end本身；如果end为空，截取到最后。12var str = &quot;abcdefgd&quot;;console.log(str.slice(1,4));// bcd 8、split()将字符串切割成数组，可以按照指定的字符来切割字符串之间的元素12var str = &quot;a-b-c-d-e-f-g&quot;;console.log(str.split(&quot;-&quot;));// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS——选择器]]></title>
    <url>%2F2019%2F05%2F09%2FCSS_selectors%2F</url>
    <content type="text"><![CDATA[选择器的作用规范了页面中哪些元素能够使用定义好的样式，为了匹配元素，可以把选择器看成匹配规则，符合规则的标签就能够应用样式。 基本选择器1.通用选择器(*)可以与页面重任何标签都匹配注意，匹配所有标签，效率极低,尽量少用。唯一一种项目中有可能使用*{margin:0;padding:0;} 2.元素选择器(标签名)设置页面中某些元素的默认样式eg:div{} p{} span{} header{} a{} body{}… 3.类选择器(.)定义页面上某个或者某类元素的样式(公共的样式，谁想用谁就可以使用)特点：通过元素的class属性来引用语法： 1.声明，必须以.开头。点是不能省略 2.引用使用的时候，直接写在class中，没有点.点 3.类名不能以数字开头 4.不能包含特殊字符(除了 - , _ )特殊用法1：多类选择器,让元素同时引用多个类,空格隔开特殊用法2:分类选择器，标签选择器和类选择的联合使用标签名.类名{}(1)指向更精确(2)样式优先级变高 4.ID选择器(#)设置指定id元素的样式（专属样式） #id值{} 5.群组选择器(选择器一,选择器二,…..)将多个选择器放在一起定义公共样式选择器1，选择器2，选择器3…….{} 6.后代选择器(主 后代一 后代二)通过元素的后代关系匹配元素一级或者多余一级的嵌套语法：选择器1 选择器2 选择器3{} 多个选择器用空格分割 7.子代选择器(&gt;)通过元素的子代关系(一级嵌套)匹配元素选择器&gt;选择器{} 8.伪类选择器(:)匹配元素不同状态的选择器选择器:伪类选择器{}8.1链接伪类:link 匹配元素尚未访问时的状态:visited匹配元素访问后的状态8.2动态伪类:hover 匹配元素鼠标悬停时的状态:active 匹配元素被激活时的状态:focus 匹配元素获取焦点时的状态 复杂选择器1.兄弟选择器(+,~)兄弟元素：基本相同父级元素的平级元素，称为兄弟元素注意：兄弟选择器只能往后找，不能往前找1.相邻兄弟选择器(+) 选取紧紧挨着在第一个选择器后面的兄弟元素 选择器1+选择器2{}2.通用兄弟选择器(~) 获取第一个选择器后面所有满足条件的兄弟元素 选择器1~选择器2{} 2.属性选择器(attr)允许通过元素的属性，及其属性值来匹配元素1.[attr]attr表示任意属性匹配页面在红所有附带attr属性的元素[id] 匹配有id的元素, [class]匹配有class的元素2.elem[attr] elem代表元素 attr代表属性 匹配页面中所有附带attr属性的elem元素 p[id] 匹配所有带id属性的p标签3.[attr1][attr2]….{} 匹配同时附带多个属性的元素4.[attr=value] 匹配attr属性值为value的元素5.属性内容 [attr~=value] 属性值中包含指定单词的元素 [attr^=value] 属性值的首字符是指定字符的元素 [attr$=value] 属性值的尾字符是指定字符的元素 [attr*=value] 属性值中包含指定字符的元素 3.伪类选择器(:)1.目标伪类(:target)突出显示活动的html锚点元素，匹配被激活的锚点样式选择器:target{}2.结构伪类structp:first-child{color:#f00;}匹配的元素是属于p标签的父元素的第一个子元素p:last-child{color:#ff0;}匹配的元素是属于p标签的父元素的最后一个子元素p:nth-child(3){color:#f0f;}匹配的元素是属于p标签的父元素的第3个子元素3.无子元素的元素(:empty)匹配没有子元素的元素p:empty{}4.elem:only-child匹配的元素是elem的父元素中，只有elem一个子元素5.否定伪类(elem:not(selector))匹配括号中selector的元素都不要p:not([title]){ color:#00f;}6.内容生成使用css动态的向某个元素中插入一段内容所谓的内容，可以文本，也可以是元素6.1 elem::before 或者 elem:before (::before)我还会回来的6.2 elem::after 或者 elem:after 我还会回来的(::after)6.3 内容属性 content: 取值:文本/url(img) 内容生成可以解决的问题1.子元素外边距溢出在父元素的第一个子元素位置添加(::before)添加的是一个空的(content:’’;)table标签(display:table)2.高度坍塌123456789101112131415&lt;div id=&quot;parent&quot;&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;style&#123; #parent&gt;div&#123; float: left //会造成父元素高度坍塌 &#125; #parent:after&#123; //解决办法 content:&quot;&quot;; display:block; clear:both; &#125;&#125; 选择器的权值权值：表示当前选择器的重要程度，权值越大优先级越高!important &gt;1000内联样式 1000id选择器 100类和伪类选择器 10元素选择器 1通用选择器 0继承的样式 无权值1.当一个选择器中含有多个选择器时，需要将所有的选择器的权值进行相加，再进行比较，权值高的优先级高。2.选择器的权值计算，不会超过其权值的最大数量级（100个id选择器，权值的总和，也不会到1000）3.分组、群组选择器的权值，各算各的，不相加4.样式后面加!important，该样式直接获取最高优先级 内联样式不能加!important5.权值相同，使用就近原则]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F05%2F08%2FregExp%2F</url>
    <content type="text"><![CDATA[正则表达式正则表达式(Regular Expression)：专门描述字符串中字符出现规则的表达式。简单来说：因为程序不认识人类语言中的词汇，所以才需要程序员用正则表达式教程序认识人类语言中的词汇。 字符集1.要匹配一位小写字母：[a-z]2.要匹配一位大写字母：[A-Z]3.要匹配一位字母： [A-Za-z]4.要匹配一位字母或数字：[0-9A-Za-z]5.要匹配一位汉字：[\u4e00-\u9fa5] 预定义字符集正则表达式语法为四种最常用的字符集定义了最简化写法，称为预定义字符集。1.要匹配一位数字： \d 等效于 [0-9]2.要匹配一位字母、数字或: \w 等效于 [0-9A-Za-z]3.要匹配一位空字符： \s 可匹配 空格、制表符Tab等空白4.要匹配所有文字（通配符）： . 数量词数量词，是专门规定一个字符集出现次数的规则。只要一个字符集在规则中可能连续反复出现多次，就要用数量词以简写方式定义出现次数。数量词紧跟在其修饰的字符集之后，默认修饰相邻的前一个字符集。数量词包括两大类：1.有明确数量边界的数量词:(1)字符集{n} 表示字符集必须重复n次，不能多也不能少,比如：\d{4} 表示有且仅有4位数字(2)字符集{n,m} 表示字符集至少重复n次，最多重复m次，比如: \d{4,6} 表示4到6位数字(3)字符集{n,} 表示字符集匹配的内容至少重复n次，多了不限，比如：\d{6,} 表示6位以上数字2.没有明确数量边界的数量词:(1) *——可有可无，多了不限(2) ?——可有可无，最多一次(3) +——至少一次，多了不限 分组分组：将多个子规则视为一组，再和分组外的规则匹配。只要希望将多个子规则视为一个整体，再和其它规则匹配时，就用分组。例如：([我卧握]|wo)\s*([草艹操槽]|cao) 就可防住很多”卧槽” 指定匹配位置如果只希望匹配特殊位置上的关键词时，就可用特殊符号表示特殊位置。指定匹配位置包括：1.^ 表示字符串开头2.$ 表示字符串结尾3.\b 表示单词边界，可匹配：空格，标点符号，字符串开头和结尾等可将一个单词与其它单词分割开的符号。例如：1.匹配任意一组连续的空字符 \s+2.仅匹配开头的空字符 ^\s+3.仅匹配结尾的空字符 \s+$]]></content>
  </entry>
  <entry>
    <title><![CDATA[布局方式--响应式布局]]></title>
    <url>%2F2019%2F04%2F29%2Fresponse_layout%2F</url>
    <content type="text"><![CDATA[响应式布局可以根据浏览器设备的不同(pc/pad/phone)自动的更改布局，图片，文字效果，不会影响用户浏览体验 使用响应式布局的要求1.布局：不能固定宽度，必须是流式布局2.文字和图片大小随着容器大小而改变，单位为em、rem、%3.媒体查询技术(根据不同的设备类型，使用不同的显示效果) 如何编写响应式网页1.在meta中声明viewport元标签1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; 2.所有内容/文字/图片 使用相对尺寸，不要使用绝对值123456.container&#123; width:1000px;//不可取 width:100%; font-size:16px; //不可取 font-size:1rem;&#125; 3.使用流式布局+弹性布局，再搭配媒体查询技术 实现方式 float+flex4.使用CSS3 Media Query技术123@media screen and (min-widht:768px) and (max-width:991px)&#123; 选择器&#123;样式&#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[布局方式--弹性布局]]></title>
    <url>%2F2019%2F03%2F23%2Fflex%2F</url>
    <content type="text"><![CDATA[弹性布局弹性布局是一种布局方式，主要解决某元素中子元素的布局方式，为布局提供了最大的灵活性。 弹性布局中的专有名词1.容器：要使用弹性布局的子元素的父元素称之为容器;2.项目：要使用弹性布局的子元素称之为项目;3.主轴：(1)项目们排列的方向的一根轴，称之为主轴;(2)如果项目们按照横向排列，那么x轴是主轴;(3)如果项目们按照纵向排列，那么y轴是主轴;4.交叉轴：与主轴方向垂直相交轴，称之为交叉轴。 语法将元素变为弹性容器,那么他所有的子元素将变为弹性项目,所有子元素都允许按照弹性布局的方式排列:属性：display取值：1.flex ; 2.inline-flex;123.parent&#123; display: flex;&#125; 注意：元素设置成为flex容器之后:(1)项目(子元素)的float/clear/vertical-align属性失效;(2)项目允许修改尺寸;(3)容器的对齐方式text-align失效。 弹性布局的属性指定容器的主轴及其排列的方向属性:flex-direction;取值:(1)row 默认 主轴x轴，起点在左端，终点在右端;(2)row-reverse 主轴x轴，起点在右端，终点在左端;(3)column 主轴y轴，起点在顶端，终点在底端;(4)column-reverse主轴y轴，起点在底端，终点在顶端; 设置项目压缩/换行属性:flex-wrap;取值:(1)nowrap 默认值，空间不够，不换行，项目会自动缩小;(2)wrap 空间不够，项目不会缩小，换行;(3)wrap-reverse空间不够，项目不会缩小，换行并反转; 项目在主轴上的对齐方式属性:justify-content;取值:(1)flex-start 在主轴的起点对齐;(2)flex-end 在主轴的终点对齐;(3)center 在主轴居中对齐;(4)space-between 两端对齐;(5)space-around 每个间距相同; 项目在交叉轴上的对齐方式属性:align-items;取值:(1)flex-start 在交叉轴的起点对齐;(2)flex-end 在交叉轴的终点对齐;(3)center 在交叉轴的中心对齐;(4)baseline 在交叉轴的基线对齐;(5)stretch 如果未设置尺寸，在交叉轴上沾满所有空间; 项目的属性该属性只能设置一个项目，不影响容器及其他项目。(1)排序–order: 定义项目的排列顺序，值越小越靠近起点，默认值为0; 取值，无单位整数;(2)定义项目的放大比例–flex-grow:取值，无单位的整数数字，默认值为0，不放大;如果容器有足够大的剩余空间，项目将按比例放大;(3)定义项目的缩小比例–flex-shrink:无单位整数，默认值为1，空间不足时，等比缩小;取值越大，缩的越快;(4)设置某一个项目在交叉轴的对齐方式–align-self:与其它项目无关1)flex-start 在交叉轴的起点对齐;2)flex-end 在交叉轴的终点对齐;3)center 在交叉轴的中心对齐;4)baseline 在交叉轴的基线对齐;5)stretch 如果未设置尺寸，在交叉轴上沾满所有空间;6)auto 继承父元素的align-items效果;]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何解决浮动问题带来的影响]]></title>
    <url>%2F2019%2F03%2F20%2Fclear%2F</url>
    <content type="text"><![CDATA[浮动带来的影响有很多时候，我们都会用到浮动，而我们有时候对浮动只是一知半解，却不是太清楚它到底是怎么回事，不知道各位有没有和我一样的感觉，只知道用它，却不知道它到底是怎么回事，所以，在学习的过程中，就要把一个概念不是很清晰的问题把它弄清楚了，便于我们以后的使用。早些时候，W3C规定出来的浮动实际并不是为了布局所用，当时是为了做文字环绕才使用到浮动，后来有人发现用它来做布局也挺不错啊，但是，用到了浮动，是要付出一定的代价的，我们就必须要处理浮动所带来的影响。接下来我们就聊聊浮动的那些事儿，此分享仅供参考，有什么不足的地方希望各位博友指正！浮动带来的影响是什么呢？来，一起看看下面的代码：1234567891011&lt;style&gt; .child&#123; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;浮动1&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;浮动2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 这段代码看似没什么问题，但是当我们查看class=”parent”的高度时，就出现问题了。此时它的高度变为0了，这一现象也就是我们所说的“高度坍塌”。那么如何解决呢？我总结了以下几种方法： 方法一:使用overflow属性来清除浮动1234567891011121314&lt;style&gt;.child&#123; float: left;&#125;.parent&#123; overflow: hidden;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;浮动1&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;浮动2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 先找到浮动盒子的父元素，再在父元素中添加一个属性：overflow:hidden,就是清除这个父元素中的子元素浮动对页面的影响。注意：一般情况下也不会使用这种方式，因为overflow:hidden有一个特点，离开了这个元素所在的区域以后会被隐藏（overflow:hidden会将超出的部分隐藏起来）。 方法二:使用额外标签法12345678910111213141516&lt;style&gt; .child&#123; float: left; &#125; .clear&#123; height: 0px; clear: both; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;浮动1&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;浮动2&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;div&gt; &lt;/div&gt;&lt;/body&gt; 在浮动的盒子之下再放一个标签，在这个标签中使用clear:both，来清除浮动对页面的影响。1.内部标签：会将这个浮动盒子的父盒子高度重新撑开.2.外部标签：会将这个浮动盒子的影响清除，但是不会撑开父盒子.注意：一般情况下不会使用这一种方式来清除浮动。因为这种清除浮动的方式会增加页面的标签，造成结构的混乱. 方法三:使用伪元素来清除浮动(:after)1234567891011121314151617181920&lt;style&gt;.child&#123; float: left;&#125;.clearfix:after&#123; content:&quot;&quot;;//设置内容为空 height:0;//高 display:block;//将文本转为块级元素 clear:both;//清除浮动 &#125;.clearfix&#123; zoom:1;//为了兼容IE&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;浮动1&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;浮动2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 这种方法是我们平时在解决高度坍塌这一问题中最常用的方法，也是最实用的方法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6新特性]]></title>
    <url>%2F2019%2F03%2F19%2FES6%2F</url>
    <content type="text"><![CDATA[let/const: 代替var/const来声明变量和常量1.因为传统的var和const会被声明提前；2.没有块级作用域: for if while都不是作用域，其中的变量会被提前到外部，影响外部的代码。使用后:1.不会被提前，不允许提前使用未声明的变量；2.让for if while等程序块，也变为作用域原理: let自动添加匿名函数自调来划分临时作用域，并将变量名前自动加_，与其他变量区分。 参数增强1.默认值(default): 即使用户不传入参数，参数也有备用的默认值代替如何使用:定义函数时: function fun(形参,…,形参=默认值)；注意:有默认值得参数，必须在形参列表的末尾。2.剩余参数(rest): 代替arguments接收所有不确定个数的参数使用arguments有两个问题:1.不是数组类型，不能使用数组API2.只能获得全部参数，无法有选择的获得部分 如何: 定义函数时: function fun(形参,…, …数组名) 其中: 数组可收集除前几个确定参数之外的剩余参数3.散播(spread): 代替apply专门用于打散数组为单个元素，再传入函数。apply的问题: 主要功能是替换this，顺便可以打散数组为单个值。如何: 调用函数时: fun(…数组) 箭头函数: 对一切回调函数或匿名函数自调的简写如何使用: 回调函数: function (形参,…){ … }； 可简化为: (形参,…)=&gt;{ … }； 如果只有一个形参，可省略()； 如果函数体中只有一句话，可省略{}； 如果这仅有的一句话还是return xxx，则必须省略return。特点: 箭头函数内外的this是同一个/共通的。注意: 如果希望内外this相同时，应该简化；如果反而希望内外this不同时，不能简化。 参数解构: 从一个大的对象中抽取想要的部分成员，单独使用1.数组解构: 从数组中抽取想要的元素出来，单独使用如何使用: 下标对下标:123var arr=[1,2,3];var [x,y,z]=arr;console.log(x,y,z); //x=1, y=2, z=3 2.对象解构: 从对象中抽取想要的成员出来，单独使用如何使用: 属性名对属性名12var obj=&#123;x:1, y:2, z:3&#125;;var &#123;x,y,z&#125;=obj; //x属性值为1、y属性值为2、z属性值为3 Promise: 代替回调函数，实现多个异步调用，顺序执行问题: 使用回调函数方式实现多个异步调用顺序执行会导致回调地狱(callback hell)根源: 所有回调函数规定，在调用函数前，就要提前传入到函数中解决: 让回调函数在函数后传入如何: 前提: 不要在参数列表里传递回调函数了！具体实现方案前面有提到，可点击此处查看promise总结篇。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何居中一个元素]]></title>
    <url>%2F2019%2F03%2F17%2Fcss_center%2F</url>
    <content type="text"><![CDATA[一、水平居中1.行内元素水平居中利用text-align：center可以实现在块级元素内部的行内元素水平居中。123.parent&#123;//在父容器设置 text-align:center;&#125; 2.块级元素的水平居中(1).将该块级元素左右外边距设置为auto1234.child&#123; width:100px;//确保该块级元素定宽 margin:0 auto;&#125; (2)使用absolute+transform先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过想做移动子元素的一半宽度以达到水平居中。12345678.parent&#123; position:relative;&#125;.child&#123; position:absolute; left:50%; transform:translateX(-50%);&#125; 注意：transform属于css3内容，存在兼容性问题，高版本浏览器需要添加一些前缀。(3)使用flex+justify-content通过css3中的布局利器justify-content属性来打到水平居中。1234.parent&#123; display:flex; justify-content:center;&#125; (4)使用flex+margin通过将父元素设置为flex布局，再设置子元素居中。123456.parent&#123; display:flex;&#125;.child&#123; margin:0 auto;&#125; (5)使用absolute+负margin(已知高度宽度)通过绝对定位元素距离左边50%，并设置margin-left向左偏移元素宽度的一半就能实现。123456789.parent&#123; position:relative;&#125;.child&#123; position:absolute; left:50%; width:100px; margin-left:-50px;&#125; 二.垂直居中1.行内元素垂直居中1234#span&#123; height:120px; line-height:120px;&#125; 2.块级元素垂直居中(1)使用absolute+负margin(已知高度宽度)通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半就能实现。123456789.parent&#123; position:relative;&#125;.child&#123; position:absolute; top:50%; height:100px; margin-top:-50px;&#125; (2)使用absolute+transform当垂直居中的元素的高度和宽度未知时，可以借助css3中的transform属性向Y轴偏移50%的方法实现垂直居中。12345678.parent&#123; position:relative;&#125;.child&#123; position:absolute; top:50%; transform:translateY(-50%);&#125; (3)使用flex+align-items通过设置flex布局中的属性align-items，使子元素垂直居中。1234.parent&#123; display:flex; align-items:center;&#125; 三.水平垂直居中1.绝对定位与负边距实现(已知高度和宽度)123456789#container&#123; position:relative;&#125;#center&#123; position:absolute; top:50%; left:50%; margin:-50px 0 0 -50px;&#125; 2.绝对定位+css3(未知元素的高度和宽度)123456789#container&#123; position:relative;&#125;#&#123; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);&#125; 3.flex布局123456#container&#123; height:100vh;//必须有高度 display:flex; justify-content:center; align-items:center;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识]]></title>
    <url>%2F2019%2F03%2F16%2FJS%2F</url>
    <content type="text"><![CDATA[标识符所谓标识符，就是指变量、函数、属性的名字，或则函数的参数。标识符可以是按照下列格式规则组合起来的一或多个字符：1.第一个字符必须是一个字母、下划线(_)或则一个美元符号($);2.其他字符可以是字母、下划线、美元符号或数字;3.不能把关键字、保留字、true、false和boolean作为标识符。 数据类型JS中数据类型分为两类：原始数据类型、引用数据类型。1.原始数据类型又分为：数值型(number)、字符串型(string)、布尔型(boolean)、未定义型(undefined)、空(null)。原始数据类型的数据存储在栈内存中，复制一个原始类型的数据，会重新创建一个内存空间，把原来的值复制过去，和原来的值没有任何关系。2.引用数据类型又分为：对象、数组等。存储在堆内存，会在栈内存中保存存储的地址。复制一个对象的变量就相当于复制了对象的地址。 数据类型–隐式转换1.数字+字符串==&gt;string1+&quot;a&quot;; //&quot;1a&quot;2.数字+布尔==&gt;number1+true; //21+false; //13.字符串+布尔==&gt;string&quot;hello&quot;+true; //&quot;hellotrue&quot;由此可知：任何数据和字符串执行加法运算，结果都为字符串。 数据类型–强制转换1.将任意数据类型转换为整型，如果转换失败则返回NaN。–parseInt()parseInt(&quot;123abc&quot;); //123parseInt(&quot;a&quot;); //NaN2.将任意类型数据转为浮点型，如果转换失败返回NaN。–parseFloat()parseFloat(&#39;1.5&#39;) //1.53.将任意类型数据转为数值型。–Number()Number(&#39;1.5&#39;) //1.5Number(&#39;1.5a&#39;) //NaN如果要转换的字符串中含有非数字，则返回NaN4.将任意类型数据转为字符串。–toString()var num=20;num.toString(16);在转为字符串的同时，可以将数据转为2,8,16进制 逻辑短路&amp;&amp; 如果第1个条件为false的时候，就不需要再执行第2个条件|| 如果第1个条件为true的时候，就不需要再执行第2个条件 对比break、continue、return用法1.break结束循环，结束switch-case中某一个情况2.continue 跳出某一次循环，继续执行下一次循环3.return 终止函数的执行 js内置对象内置对象有以下几种:1.String对象：处理所有的字符串操作2.Math对象：处理所有的数学运算3.Date对象：处理日期和时间的存储、转化和表达4.Array对象：提供一个数组的模型、存储大量有序的数据5.Event对象：提供JavaScript事件的各种处理信息 数组中的方法1.join() 将数组转为字符串，可以按照指定的字符来拼接数组之间的元素。2.concat(arr2,arr3…) 合并多个数组中的元素。3.slice(start,end) 截取数组中的元素，start开始的下标，end结束的下标，不包含结束的下标；如果end为空，截取到最后。4.splice(start,count,value1,value2…) 删除数组中的元素；start开始删除的下标，count删除的数量，value1…删除后添加的元素；如果count为空表示从下标开始删除到最后。5.reverse() 翻转数组中的元素。6.sort() 对数组元素排序，默认按照Unicode码由小到大排序1234sort(function(a,b)&#123; return a-b; //数字由小到大 return b-a; //数字由大到小 &#125;) 7.push() 在数组的最后添加元素，返回数组的长度8.pop() 删除数组中的最后一个元素，返回删除的元素9.unshift() 在数组的开头添加元素，返回数组的长度10.shift() 删除数组中的第一个元素，返回删除的元素 字符串中的方法1.toUpperCase() 英文字符转为大写2.toLowerCase() 英文字符转为小写3.charAt() 获取下标对应的字符4.charCodeAt() 将某个字符转为Unicode码5.indexOf(value,start) 查找某个字符(串)对应的下标；value要查找的字符(串)，start开始查找的下标，默认是0；找不到返回-1.6.lastIndexOf(value) 倒着查找某一个字符，value要查找的字符7.slice(start,end) 截取字符串，start开始的下标，end结束的下标，不包含end本身；如果end为空，截取到最后。8.split(sep) 按照指定的字符将字符串分割为数组。sep表示分隔符。9.replace(value1,value2) 用于查找字符串，并使用另一个字符串替换。value1要查找的字符串，value2要替换的字符串；value1可以是用匹配模式的写法 /china/gi g -&gt; global 全局匹配 i -&gt; ignore 忽略查找中大小写10.match(value) 用于查找某个字符串出现的次数，返回数组，可以使用i和g11.search(value) 用于查找某个字符串，返回满足条件的第一个字符串的下标，如果找不到返回-1，里边可以使用i; Math对象Math对象不需要使用new来创建，可以直接调用。PI 取圆周率abs() 取一个数字的绝对值round() 四舍五入取整ceil() 向上取整floor() 向下取整max() 取多个数字的最大值min() 取多个数字的最小值pow(x,y) 取x的y次幂random() 取随机数，范围0~1之间 Date对象1.创建对象(1)new Date(‘2018/10/1 18:20:30’)(2)new Date(2018,9,1,18,20,30) //第2个参数月份范围0~11(3)new Date(1000) //距离计算机元年(1970-1-1 0:0:0)的时间，单位是毫秒 1000毫秒=1秒钟(4)new Date() //当前的系统时间2.获取具体时间信息getFullYear()/getMonth()/getDate()/getHours()/getMinutes()/getSeconds()/getMilliseconds()/getDay()/getTime()获取年/月/日/小时/分钟/秒钟/毫秒/距离计算机元年毫秒数3.本地化日期时间格式(1)toLocaleString() 年-月-日 时 : 分 : 秒(2)toLocaleDateString() 年-月-日(3)toLocaleTimeString() 时 : 分 : 秒4.设置日期时间setFullYear()/setMonth()/setDate()/setHours()/setMinutes()/setSeconds()/setMilliseconds()/setTime()设置年/月/日/小时/分钟/秒钟/毫秒/距离计算机元年毫秒数]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中new都做了哪些事儿]]></title>
    <url>%2F2019%2F03%2F10%2Fnew%2F</url>
    <content type="text"><![CDATA[关于new的介绍new运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例举个栗子：123456789function Car(color)&#123; this.color = color;&#125;Car.prototype.start = function()&#123; console.log(this.color + &quot;car start&quot;);&#125;var car = new Car(&quot;black&quot;);car.color;//访问构造函数里的属性，结果为blackcar.start();//访问原型里的属性，结果为black car start 可以看出new创建的实例有以下2个特征：1.访问到构造函数里的属性2.访问到原型里的属性 new具体干了什么new一共经历以下4个阶段：1、创建一个空对象var obj = new Object();2、设置原型链此时便建立了obj对象的原型链obj.__proto__ = Object.prototype;3、让Func的this指向obj，并执行Func函数体Object.call(obj);4、判断Func的返回值类型如果是值类型，返回obj；如果是引用类型，返回这个引用类型的对象。return typeof result === &#39;obj&#39;? result : obj;简单来说就是：首先创建新的对象; 然后将构造函数作用域指向该对象; 其次执行构造函数里的代码; 最后返回该对象;]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器访问服务器的过程中丢包了，但返回的status为200。原因是什么]]></title>
    <url>%2F2019%2F03%2F08%2FProtocol%2F</url>
    <content type="text"><![CDATA[要想清楚的理解这个问题，我们得需要了解协议 HTTP、HTTPS、TCPHTTP（Hypertext transfer protocol，超文本传输协议）是一种详细规定了浏览器和服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。简单来说，HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。HTTPS（Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内 [1] 另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。默认HTTP的端口号为80，HTTPS的端口号为443。为什么HTTPS安全因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性。在了解了协议的概念之后我们在来看一下丢包这一问题： 什么是丢包丢包（Packet loss）是指一个或多个数据数据包（packet）的数据无法透过网上到达目的地。丢包与比特错误（bit error）与噪声（noise）所造成的虚假的数据包（spurious packets）是三个最主要的数字通信错误的原因。 发生丢包的原因是什么丢包可能原因是多方面，包括在网上中由于多路径衰落（multi-path fading）所造成的信号衰减（signal degradation），或是因为通道阻塞造成的丢包（packet drop），再者损坏的数据包（corrupted packets）被拒绝通过，或有缺陷的网上硬件，网上驱动程序故障都可能造成丢包。此外，丢包也受信号的信噪比（SNR）的影响。 如何解决丢包1.网络数据包发送时通时断，丢包严重。解决办法：当发现网络数据包发送时通时断，丢包严重，特别是整个单位或整个楼层出现振荡性中断现象时，则可以判定应该是该单位的某个交换机上出现了环路所致。作为网络管理人员应首先查看各接入交换机的指示灯闪烁状态，通常出现环路状况会指示灯会急速闪烁，次数每秒4次以上，所环交换机更为突出。逐个拨出交换机级联接入网线，同时实时监控交换机状态，在拨下某端口网线后，交换机指示灯恢复正常状态，再进一步查找，会发现该连接线的末端有线路形成环路，清理该网线后，网络恢复畅通。2.网络数据包发送超时现象严重，时有不规则丢包。解决办法：找到问题根源后，对主机进行隔离，经过一段时间的测试，网络丢包现象有所缓解，但没有从根本上解决问题。于是再次启动网络协议分析系统捕获并分析，又发现了1台相似情况的主机。据此基本可以断定两台主机都是感染了病毒，且该病毒会主动扫描网络中其他主机是否打开TCP 445端口，如果某主机打开该端口，就攻击并感染这台主机。如此循环，即引发了上述的网络故障。立即对新发现感染病毒的两台主机进行物理隔离，网络通信立刻恢复正常，再对该终端进行杀毒处理。3.网络数据包发生严重延时现象，下载、浏览等服务不能正常使用。解决办法：进入该端口配置界面下，输入Shutdown命令，强制关闭该端口使其断网，联系该终端使用人员，令其终止下载进程后，再恢复其网络。]]></content>
  </entry>
  <entry>
    <title><![CDATA[对promise的理解]]></title>
    <url>%2F2019%2F03%2F07%2Fpromise%2F</url>
    <content type="text"><![CDATA[什么是PromisePromise是最早由社区提出和实现的一种解决异步编程的方案，比其他传统的解决方案（回调函数和事件）更合理和更强大。 Promise是为了解决哪一问题而产生的当我们需要让多个异步函数按顺序执行时，我们需要层层嵌套。这种层层嵌套关系就是我们经常提到的回调地狱。这样一来不仅使代码失去了可维护性，还会是整个代码看起来非常复杂。因此ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。并且规定，Promise对象是一个构造函数，用来生成Promise实例。 Promise的特点1.Promise对象的状态不受外界影响(1)pending 初始状态(2)fulfilled 成功状态(3)rejected 失败状态Promise 有以上三种状态，只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变这个状态2.Promise的状态一旦改变，就不会再变，任何时候都可以得到这个结果，状态不可以逆，只能由 pending变成fulfilled或者由pending变成rejected Promise的缺点1.无法取消Promise,一旦新建它就会立即执行，无法中途取消2.如果不设置回调函数，Promise内部抛出的错误，不会反映到外部3.当处于pending状态时，无法得知目前进展到哪一个阶段，是刚刚开始还是即将完成 Promise的优点1.代码结构更加扁平且更可读，清晰明了。2.能解决回调地狱问题。3.可将数据请求和业务逻辑分离开来。4.便于管理维护。5.能更好的捕获错误。 Promise在哪存放成功回调序列和失败回调序列1.onResolvedCallbacks:成功后要执行的回调序列。是一个数组；2.onRejectedCallbacks:失败后要执行的回调序列。是一个数组；以上两个数组存放在Promise 创建实例时给Promise这个类传的函数中，默认都是空数组。每次实例then的时候 传入 onFulfilled 成功回调 onRejected 失败回调，如果此时的状态是pending 则将onFulfilled和onRejected push到对应的成功回调序列数组和失败回调序列数组中，如果此时的状态是fulfilled 则onFulfilled立即执行，如果此时的状态是rejected则onRejected立即执行上述序列中的回调函数执行的时候 是有顺序的，即按照顺序依次执行 Promise的用法Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。1234567const promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125; &#125;); resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。12345promise.then(function(value) &#123; // success &#125;, function(error) &#123; // failure &#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 Promise的链式写法12345678910111213let promise = new Promise(function (resolve, reject) &#123; resolve(100);// reject(100) &#125;); promise.then(function (data) &#123; return data+100; &#125;,function (err) &#123; return &apos;ssss&apos;; &#125;).then(function (data) &#123; console.log(data);// 200 // undefined // sss &#125;) 从上面的例子可以看出:当第一个promise的成功的回调里返回 200时，第二个promise的成功回调的参数就是200；当将resolve(100)改成reject(100)的时候，因为失败回调中什么也没有返回所以第二个promise的成功回调中的参数是undefined；当失败的回调中返回sss时，第二个promise的成功回调中的参数是sss；由此我们可以看出，第一个promise不管成功回调还是失败回调，他的返回值作为第二个promise中的成功时回调函数的参数值；链式写法能一直then下去的原因：链式调用靠的是返回新的promise，来保证可以一直走成功或失败。]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域的解决方法]]></title>
    <url>%2F2019%2F03%2F07%2FACAO%2F</url>
    <content type="text"><![CDATA[什么是跨域从一个域名下的网页，向另一个域名下的服务端发送请求。这时候就会出现跨域问题。例如：1.域名不同: www.a.com/index.js -&gt; www.b.com/index2.二级域名不同: www.a.study.com/index.js -&gt; www.b.study.com/index3.端口不同: localhost:5500 -&gt;localhost:80004.协议不同: http://localhost -&gt; https://localhost5.域名 -&gt; IP地址以上五种情况，均禁止ajax发送异步请求。 解决方法1.JSONP：原理：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里12345678910111213141516171819&lt;script&gt; function createJs(sUrl)&#123; var oScript = document.createElement(&apos;script&apos;); oScript.type = &apos;text/javascript&apos;; oScript.src = sUrl; document.getElementsByTagName(&apos;head&apos;)[0].appendChild(oScript); &#125; createJs(&apos;jsonp.js&apos;); box(&#123; &apos;name&apos;: &apos;test&apos; &#125;); function box(json)&#123; alert(json.name); &#125;&lt;/script&gt; 但是要注意JSONP只支持GET请求，不支持POST请求。2.CORS服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。12345678//1:加载模块corsconst cors = require(&quot;cors&quot;);//2:配置corsapp.use(cors(&#123; origin:[&quot;http://127.0.0.1:3001&quot;, &quot;http://localhost:3001&quot;],//允许列表 credentials:true //是否验证&#125;)); 3.window.namewindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的4.CSS Text Transformation既然可以利用script的漏洞来进行JSONP跨域，那么是不是也可以利用css样式写可以进行跨域请求来进行跨域呢？答案肯定是可以的，利用css还有一个好处那就是，当被注入攻击脚本时，css尽管被注入，也不会引起什么大的安全问题，顶多也就是把页面的样式给改变，而js被注入的话，cookie就有可能被盗取等一系列安全问题出现。1234567891011121314151617181920// 前端请求代码ajaxPost(&quot;http://localhost:666?page=cors&quot;, &#123; name: &quot;zp1996&quot;, age: 20, sex: &quot;male&quot;&#125;, &#123; &quot;X-author&quot;: &quot;zp1996&quot; &#125;).then((text) =&gt; &#123; console.log(text); &#125;, () =&gt; &#123; console.log(&quot;请求失败&quot;); &#125;);// 后端处理，补充在简单请求代码注释处if (req.method === &quot;OPTIONS&quot;) &#123; res.writeHead(200, &#123; &quot;Access-Control-Max-Age&quot;: 3000, &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, &quot;Access-Control-Allow-Headers&quot;: &quot;X-author&quot;, &quot;Content-Type&quot;: &quot;application/json;charset=utf-8&quot; &#125;); res.end(); return void 0; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[json数据]]></title>
    <url>%2F2019%2F03%2F06%2Fjson%2F</url>
    <content type="text"><![CDATA[什么是jsonjson(JavaScript Object Notation)是JavaScript对象表示法;json是存储和交换文本信息的语法(类似于XML)，是一种轻量级的文本数据交换格式,比XML更快更小更易解析。 json的表示方法json的表示方法和对象相似，但又不同。有何不同呢？看个栗子：对象的写法一般是： var aa ={name:&quot;zoumm&quot;,job :&quot;it&quot;,age :25};而json的写法是： {&quot;name&quot;:&quot;zoumm&quot;,&quot;job&quot;:&quot;it&quot;,&quot;age&quot;:23,&quot;school&quot;:{&quot;name&quot;:&quot;大学名&quot;，“add”:&quot;中国&quot;}}由此可以看出：对象的属性名没有加引号，而json对象所有的属性名必须加双引号。 为什么json数据要解析json数据在传输的过程中是以文本格式存在的，即以字符串的形式存在，然而我们的js中操作的却是对象，因此我们必须将json数据解析成对象的操作，然后才能用对象对数据进行访问。 json的数据格式有哪些1.Json字符串： var json_str = &#39;{&quot;name&quot;:&quot;xiao&quot;,&quot;age&quot;:12}&#39;;2.Josn对象： var obj = {&quot;name&quot;:&quot;xiao&quot;,&quot;age&quot;:12}; json数据的解析1.JSON提供了json.js包，下载http://www.json.org/json.js 后，将其引入然后就可以简单的使用object.toJSONString()转换成JSON数据。2.用eval()方法转换到Object，再obj.toJSONString()12345function myEval() &#123; var str = &apos;&#123; &quot;name&quot;: &quot;Violet&quot;, &quot;occupation&quot;: &quot;character&quot; &#125;&apos;; var obj = eval(&apos;(&apos; + str + &apos;)&apos;); alert(obj.toJSONString());&#125; 3.JSON.parse()方法12var a=&apos;&#123;&quot;name&quot;: &quot;Violet&quot;, &quot;occupation&quot;: &quot;character&quot; &#125;&apos;JSON.parse(a) 解析后a就变成了对象a={name: “Violet”, occupation: “character” }。这样我们就可以在js中将其使用当然，也可以将js对象变为json字符串12var a=&#123;name: &quot;Violet&quot;, occupation: &quot;character&quot; &#125;JSON.stringify(a) 何时需要解析json数据当我们从后端拿出来的数据是以json的格式显示出来的，此时我们需要对其处理，即解析。只有解析之后我们才能使用从后端拿出来的数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的ajax]]></title>
    <url>%2F2019%2F03%2F06%2Fajax%2F</url>
    <content type="text"><![CDATA[什么是ajaxAjax 即Asynchronous Javascript And XML（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。换句话说，ajax是一种无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，ajax可以是网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。而传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。因此，ajax技术的出现大大提高了用户体验。ajax是异步发送请求，那么什么是异步？什么又是同步呢？我们一起来看看 异步与同步1.同步(Synchronous) 在一个任务进行中时，不能开启其它任务。 同步访问：浏览器在向服务器发送请求时，浏览器只能等待服务器的响应，不能够做其它的事情 出现场合： (1).地址栏输入网址访问网页(网速不好的时候更明显) (2).a标签跳转 (3).submit提交表单 跳转之后，前面的表单页面不能再做任何操作了2.异步(Asynchronous) 在一个任务开启时，可以开启其它任务 异步访问：浏览器在向服务器发送请求时，不耽误用户在网页的其它操作。 出现的场合： (1).用户名的重复验证 (2).聊天室 (3).搜索建议 (4).股票走势图 ajax如何实现异步请求1.创建异步对象通过window.XMLHttpRequest是否存在，来判断浏览器是否支持ajax的标准创建。如果有值，为true,进入if块，支持标准创建 var xhr=new XMLHttpRequest();如果没有值，为null，为false。不支持标准创建 var xhr=new ActiveXObject(&quot;Microsoft.XMLHttp&quot;);2.绑定监听事件—接收响应数据123456xhr.onreadystatechange=function()&#123; if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; //接收响应数据 var result=xhr.responseText; &#125; &#125; (1)readyState 用于表示xhr对象的请求状态 值0~4 表示了5个状态 0：请求尚未初始化 1：已经打开到服务器的连接，正在发送请求 2：接收响应头 3：接收响应主体 4：接收响应数据成功(2)status 表示服务器的响应状态码 值 200 当status的值为200的时候，表示服务器已经正确处理了请求(3)onreadystatechange–事件，监听器 当xhr的readystate属性值发生改变时，自动激发的操作 接收响应数据3.打开链接(创建请求)xhr.open(method,url,isAsyn);注： method:请求的方法 “get”/“post” string类型 url:请求的地址 string类型 isAsyn:是否采用异步 boolean类型 false同步 true异步4.发送请求xhr.send(body);如果有请求主体,post,就把请求主体放在body的位置如果没有请求主体，get,body处放null ajax的优缺点1.优点： (1)可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量 (2)避免用户不断刷新或者跳转页面，提高用户体验2.缺点: (1)要实现ajax下的前后退功能成本较大 (2)可能造成请求数的增加 (3)跨域问题限制]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈JavaScript中的闭包]]></title>
    <url>%2F2019%2F03%2F05%2Fclosure%2F</url>
    <content type="text"><![CDATA[什么是闭包闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。换句话说：闭包就是能够读取其他函数内部变量的函数。只有函数内部的子函数才能读取局部变量，所以闭包可以理解成定义在一个函数内部的函数。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。来 看一个栗子：123456789function outter()&#123; var i = 0; function inner()&#123; alert(++i) &#125; return inner;&#125;var res = outter();res() 这段代码有两个特点： 1、内层函数inner被外层函数outter包裹 2、执行函数outter返回函数inner这样执行完var res = outter()后，变量res实际上是指向了函数inner，inner中用到了变量i，再执行res()后就会弹出一个窗口显示i的值。这段代码其实就创建了一个闭包。说简单一点：当函数outter的内部函数inner被函数outter外的一个变量引用的时候，就创建了一个我们通常所谓的闭包 闭包的作用闭包的作用就是在outter执行完并返回后，闭包使得Javascript的垃圾回收机制不会收回outter所占用的资源，因为outer的内部函数inner的执行需要依赖outter中的变量。在上面的例子中，由于闭包的存在使得函数outter返回后，outter中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。那么我们来想象另一种情况，如果outter返回的不是函数inner，情况就完全不同了。因为outter执行完后，inner没有被返回给outter的外界，只是被outter所引用，而此时outter也只会被inner引 用，因此函数outter和inner互相引用但又不被外界打扰（被外界引用），函数outter和inner就会被回收 何时使用闭包当一个变量需要被保护，使其不会被全局污染时使用 使用注意1、由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2019%2F03%2F05%2Fmy%20first%20blog%2F</url>
    <content type="text"><![CDATA[Welcome to Xiao Cheng’s blog. If there is anything wrong, please do more correction.My email. instructionHere, I’m going to make some of my personal understandings about the front-end with the front-end of the web. If there’s something wrong, or there’s a better way to welcome you. Thank you.]]></content>
  </entry>
</search>
