<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浏览器访问服务器的过程中丢包了，但返回的status为200。原因是什么]]></title>
    <url>%2F2019%2F03%2F08%2FProtocol%2F</url>
    <content type="text"><![CDATA[要想清楚的理解这个问题，我们得需要了解协议 HTTP、HTTPS、TCPHTTP（Hypertext transfer protocol，超文本传输协议）是一种详细规定了浏览器和服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。简单来说，HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。HTTPS（Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内 [1] 另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。默认HTTP的端口号为80，HTTPS的端口号为443。为什么HTTPS安全因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性。在了解了协议的概念之后我们在来看一下丢包这一问题： 什么是丢包丢包（Packet loss）是指一个或多个数据数据包（packet）的数据无法透过网上到达目的地。丢包与比特错误（bit error）与噪声（noise）所造成的虚假的数据包（spurious packets）是三个最主要的数字通信错误的原因。 发生丢包的原因是什么丢包可能原因是多方面，包括在网上中由于多路径衰落（multi-path fading）所造成的信号衰减（signal degradation），或是因为通道阻塞造成的丢包（packet drop），再者损坏的数据包（corrupted packets）被拒绝通过，或有缺陷的网上硬件，网上驱动程序故障都可能造成丢包。此外，丢包也受信号的信噪比（SNR）的影响。 如何解决丢包1.网络数据包发送时通时断，丢包严重。解决办法：当发现网络数据包发送时通时断，丢包严重，特别是整个单位或整个楼层出现振荡性中断现象时，则可以判定应该是该单位的某个交换机上出现了环路所致。作为网络管理人员应首先查看各接入交换机的指示灯闪烁状态，通常出现环路状况会指示灯会急速闪烁，次数每秒4次以上，所环交换机更为突出。逐个拨出交换机级联接入网线，同时实时监控交换机状态，在拨下某端口网线后，交换机指示灯恢复正常状态，再进一步查找，会发现该连接线的末端有线路形成环路，清理该网线后，网络恢复畅通。2.网络数据包发送超时现象严重，时有不规则丢包。解决办法：找到问题根源后，对主机进行隔离，经过一段时间的测试，网络丢包现象有所缓解，但没有从根本上解决问题。于是再次启动网络协议分析系统捕获并分析，又发现了1台相似情况的主机。据此基本可以断定两台主机都是感染了病毒，且该病毒会主动扫描网络中其他主机是否打开TCP 445端口，如果某主机打开该端口，就攻击并感染这台主机。如此循环，即引发了上述的网络故障。立即对新发现感染病毒的两台主机进行物理隔离，网络通信立刻恢复正常，再对该终端进行杀毒处理。3.网络数据包发生严重延时现象，下载、浏览等服务不能正常使用。解决办法：进入该端口配置界面下，输入Shutdown命令，强制关闭该端口使其断网，联系该终端使用人员，令其终止下载进程后，再恢复其网络。]]></content>
  </entry>
  <entry>
    <title><![CDATA[对promise的理解]]></title>
    <url>%2F2019%2F03%2F07%2Fpromise%2F</url>
    <content type="text"><![CDATA[什么是PromisePromise是最早由社区提出和实现的一种解决异步编程的方案，比其他传统的解决方案（回调函数和事件）更合理和更强大。 Promise是为了解决哪一问题而产生的当我们需要让多个异步函数按顺序执行时，我们需要层层嵌套。这种层层嵌套关系就是我们经常提到的回调地狱。这样一来不仅使代码失去了可维护性，还会是整个代码看起来非常复杂。因此ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。并且规定，Promise对象是一个构造函数，用来生成Promise实例。 Promise的特点1.Promise对象的状态不受外界影响(1)pending 初始状态(2)fulfilled 成功状态(3)rejected 失败状态Promise 有以上三种状态，只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变这个状态2.Promise的状态一旦改变，就不会再变，任何时候都可以得到这个结果，状态不可以逆，只能由 pending变成fulfilled或者由pending变成rejected Promise的缺点1.无法取消Promise,一旦新建它就会立即执行，无法中途取消2.如果不设置回调函数，Promise内部抛出的错误，不会反映到外部3.当处于pending状态时，无法得知目前进展到哪一个阶段，是刚刚开始还是即将完成 Promise的优点1.代码结构更加扁平且更可读，清晰明了。2.能解决回调地狱问题。3.可将数据请求和业务逻辑分离开来。4.便于管理维护。5.能更好的捕获错误。 Promise在哪存放成功回调序列和失败回调序列1.onResolvedCallbacks:成功后要执行的回调序列。是一个数组；2.onRejectedCallbacks:失败后要执行的回调序列。是一个数组；以上两个数组存放在Promise 创建实例时给Promise这个类传的函数中，默认都是空数组。每次实例then的时候 传入 onFulfilled 成功回调 onRejected 失败回调，如果此时的状态是pending 则将onFulfilled和onRejected push到对应的成功回调序列数组和失败回调序列数组中，如果此时的状态是fulfilled 则onFulfilled立即执行，如果此时的状态是rejected则onRejected立即执行上述序列中的回调函数执行的时候 是有顺序的，即按照顺序依次执行 Promise的用法Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。1234567const promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125; &#125;); resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。12345promise.then(function(value) &#123; // success &#125;, function(error) &#123; // failure &#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 Promise的链式写法12345678910111213let promise = new Promise(function (resolve, reject) &#123; resolve(100);// reject(100) &#125;); promise.then(function (data) &#123; return data+100; &#125;,function (err) &#123; return &apos;ssss&apos;; &#125;).then(function (data) &#123; console.log(data);// 200 // undefined // sss &#125;) 从上面的例子可以看出:当第一个promise的成功的回调里返回 200时，第二个promise的成功回调的参数就是200；当将resolve(100)改成reject(100)的时候，因为失败回调中什么也没有返回所以第二个promise的成功回调中的参数是undefined；当失败的回调中返回sss时，第二个promise的成功回调中的参数是sss；由此我们可以看出，第一个promise不管成功回调还是失败回调，他的返回值作为第二个promise中的成功时回调函数的参数值；链式写法能一直then下去的原因：链式调用靠的是返回新的promise，来保证可以一直走成功或失败。]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域的解决方法]]></title>
    <url>%2F2019%2F03%2F07%2FACAO%2F</url>
    <content type="text"><![CDATA[什么是跨域从一个域名下的网页，向另一个域名下的服务端发送请求。这时候就会出现跨域问题。例如：1.域名不同: www.a.com/index.js -&gt; www.b.com/index2.二级域名不同: www.a.study.com/index.js -&gt; www.b.study.com/index3.端口不同: localhost:5500 -&gt;localhost:80004.协议不同: http://localhost -&gt; https://localhost5.域名 -&gt; IP地址以上五种情况，均禁止ajax发送异步请求。 解决方法1.JSONP：原理：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里12345678910111213141516171819&lt;script&gt; function createJs(sUrl)&#123; var oScript = document.createElement(&apos;script&apos;); oScript.type = &apos;text/javascript&apos;; oScript.src = sUrl; document.getElementsByTagName(&apos;head&apos;)[0].appendChild(oScript); &#125; createJs(&apos;jsonp.js&apos;); box(&#123; &apos;name&apos;: &apos;test&apos; &#125;); function box(json)&#123; alert(json.name); &#125;&lt;/script&gt; 但是要注意JSONP只支持GET请求，不支持POST请求。2.CORS服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。12345678//1:加载模块corsconst cors = require(&quot;cors&quot;);//2:配置corsapp.use(cors(&#123; origin:[&quot;http://127.0.0.1:3001&quot;, &quot;http://localhost:3001&quot;],//允许列表 credentials:true //是否验证&#125;)); 3.window.namewindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的4.CSS Text Transformation既然可以利用script的漏洞来进行JSONP跨域，那么是不是也可以利用css样式写可以进行跨域请求来进行跨域呢？答案肯定是可以的，利用css还有一个好处那就是，当被注入攻击脚本时，css尽管被注入，也不会引起什么大的安全问题，顶多也就是把页面的样式给改变，而js被注入的话，cookie就有可能被盗取等一系列安全问题出现。1234567891011121314151617181920// 前端请求代码ajaxPost(&quot;http://localhost:666?page=cors&quot;, &#123; name: &quot;zp1996&quot;, age: 20, sex: &quot;male&quot;&#125;, &#123; &quot;X-author&quot;: &quot;zp1996&quot; &#125;).then((text) =&gt; &#123; console.log(text); &#125;, () =&gt; &#123; console.log(&quot;请求失败&quot;); &#125;);// 后端处理，补充在简单请求代码注释处if (req.method === &quot;OPTIONS&quot;) &#123; res.writeHead(200, &#123; &quot;Access-Control-Max-Age&quot;: 3000, &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, &quot;Access-Control-Allow-Headers&quot;: &quot;X-author&quot;, &quot;Content-Type&quot;: &quot;application/json;charset=utf-8&quot; &#125;); res.end(); return void 0; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[json数据]]></title>
    <url>%2F2019%2F03%2F06%2Fjson%2F</url>
    <content type="text"><![CDATA[什么是jsonjson(JavaScript Object Notation)是JavaScript对象表示法;json是存储和交换文本信息的语法(类似于XML)，是一种轻量级的文本数据交换格式,比XML更快更小更易解析。 json的表示方法json的表示方法和对象相似，但又不同。有何不同呢？看个栗子：对象的写法一般是： var aa ={name:&quot;zoumm&quot;,job :&quot;it&quot;,age :25};而json的写法是： {&quot;name&quot;:&quot;zoumm&quot;,&quot;job&quot;:&quot;it&quot;,&quot;age&quot;:23,&quot;school&quot;:{&quot;name&quot;:&quot;大学名&quot;，“add”:&quot;中国&quot;}}由此可以看出：对象的属性名没有加引号，而json对象所有的属性名必须加双引号。 为什么json数据要解析json数据在传输的过程中是以文本格式存在的，即以字符串的形式存在，然而我们的js中操作的却是对象，因此我们必须将json数据解析成对象的操作，然后才能用对象对数据进行访问。 json的数据格式有哪些1.Json字符串： var json_str = &#39;{&quot;name&quot;:&quot;xiao&quot;,&quot;age&quot;:12}&#39;;2.Josn对象： var obj = {&quot;name&quot;:&quot;xiao&quot;,&quot;age&quot;:12}; json数据的解析1.JSON提供了json.js包，下载http://www.json.org/json.js 后，将其引入然后就可以简单的使用object.toJSONString()转换成JSON数据。2.用eval()方法转换到Object，再obj.toJSONString()12345function myEval() &#123; var str = &apos;&#123; &quot;name&quot;: &quot;Violet&quot;, &quot;occupation&quot;: &quot;character&quot; &#125;&apos;; var obj = eval(&apos;(&apos; + str + &apos;)&apos;); alert(obj.toJSONString());&#125; 3.JSON.parse()方法12var a=&apos;&#123;&quot;name&quot;: &quot;Violet&quot;, &quot;occupation&quot;: &quot;character&quot; &#125;&apos;JSON.parse(a) 解析后a就变成了对象a={name: “Violet”, occupation: “character” }。这样我们就可以在js中将其使用当然，也可以将js对象变为json字符串12var a=&#123;name: &quot;Violet&quot;, occupation: &quot;character&quot; &#125;JSON.stringify(a) 何时需要解析json数据当我们从后端拿出来的数据是以json的格式显示出来的，此时我们需要对其处理，即解析。只有解析之后我们才能使用从后端拿出来的数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的ajax]]></title>
    <url>%2F2019%2F03%2F06%2Fajax%2F</url>
    <content type="text"><![CDATA[什么是ajaxAjax 即Asynchronous Javascript And XML（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。换句话说，ajax是一种无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，ajax可以是网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。而传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。因此，ajax技术的出现大大提高了用户体验。ajax是异步发送请求，那么什么是异步？什么又是同步呢？我们一起来看看 异步与同步1.同步(Synchronous) 在一个任务进行中时，不能开启其它任务。 同步访问：浏览器在向服务器发送请求时，浏览器只能等待服务器的响应，不能够做其它的事情 出现场合： (1).地址栏输入网址访问网页(网速不好的时候更明显) (2).a标签跳转 (3).submit提交表单 跳转之后，前面的表单页面不能再做任何操作了2.异步(Asynchronous) 在一个任务开启时，可以开启其它任务 异步访问：浏览器在向服务器发送请求时，不耽误用户在网页的其它操作。 出现的场合： (1).用户名的重复验证 (2).聊天室 (3).搜索建议 (4).股票走势图 ajax如何实现异步请求1.创建异步对象通过window.XMLHttpRequest是否存在，来判断浏览器是否支持ajax的标准创建。如果有值，为true,进入if块，支持标准创建 var xhr=new XMLHttpRequest();如果没有值，为null，为false。不支持标准创建 var xhr=new ActiveXObject(&quot;Microsoft.XMLHttp&quot;);2.绑定监听事件—接收响应数据123456xhr.onreadystatechange=function()&#123; if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; //接收响应数据 var result=xhr.responseText; &#125; &#125; (1)readyState 用于表示xhr对象的请求状态 值0~4 表示了5个状态 0：请求尚未初始化 1：已经打开到服务器的连接，正在发送请求 2：接收响应头 3：接收响应主体 4：接收响应数据成功(2)status 表示服务器的响应状态码 值 200 当status的值为200的时候，表示服务器已经正确处理了请求(3)onreadystatechange–事件，监听器 当xhr的readystate属性值发生改变时，自动激发的操作 接收响应数据3.打开链接(创建请求)xhr.open(method,url,isAsyn);注： method:请求的方法 “get”/“post” string类型 url:请求的地址 string类型 isAsyn:是否采用异步 boolean类型 false同步 true异步4.发送请求xhr.send(body);如果有请求主体,post,就把请求主体放在body的位置如果没有请求主体，get,body处放null ajax的优缺点1.优点： (1)可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量 (2)避免用户不断刷新或者跳转页面，提高用户体验2.缺点: (1)要实现ajax下的前后退功能成本较大 (2)可能造成请求数的增加 (3)跨域问题限制]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈JavaScript中的闭包]]></title>
    <url>%2F2019%2F03%2F05%2Fclosure%2F</url>
    <content type="text"><![CDATA[什么是闭包闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。换句话说：闭包就是能够读取其他函数内部变量的函数。只有函数内部的子函数才能读取局部变量，所以闭包可以理解成定义在一个函数内部的函数。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。来 看一个栗子：123456789function outter()&#123; var i = 0; function inner()&#123; alert(++i) &#125; return inner;&#125;var res = outter();res() 这段代码有两个特点： 1、内层函数inner被外层函数outter包裹 2、执行函数outter返回函数inner这样执行完var res = outter()后，变量res实际上是指向了函数inner，inner中用到了变量i，再执行res()后就会弹出一个窗口显示i的值。这段代码其实就创建了一个闭包。说简单一点：当函数outter的内部函数inner被函数outter外的一个变量引用的时候，就创建了一个我们通常所谓的闭包 闭包的作用闭包的作用就是在outter执行完并返回后，闭包使得Javascript的垃圾回收机制不会收回outter所占用的资源，因为outer的内部函数inner的执行需要依赖outter中的变量。在上面的例子中，由于闭包的存在使得函数outter返回后，outter中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。那么我们来想象另一种情况，如果outter返回的不是函数inner，情况就完全不同了。因为outter执行完后，inner没有被返回给outter的外界，只是被outter所引用，而此时outter也只会被inner引 用，因此函数outter和inner互相引用但又不被外界打扰（被外界引用），函数outter和inner就会被回收 何时使用闭包当一个变量需要被保护，使其不会被全局污染时使用 使用注意1、由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2019%2F03%2F05%2Fmy%20first%20blog%2F</url>
    <content type="text"><![CDATA[Welcome to Xiao Cheng’s blog. If there is anything wrong, please do more correction.My email. instructionHere, I’m going to make some of my personal understandings about the front-end with the front-end of the web. If there’s something wrong, or there’s a better way to welcome you. Thank you.]]></content>
  </entry>
</search>
